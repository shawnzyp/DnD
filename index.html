<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>D&D Companion – Ask the DM</title>
    <style>
      :root {
        color-scheme: light dark;
        --bg: #0e141a;
        --surface: rgba(255, 255, 255, 0.08);
        --text: #f5f5f5;
        --accent: #d96d28;
        --accent-dark: #b3571e;
        font-family: "Inter", "Segoe UI", system-ui, sans-serif;
      }

      body {
        margin: 0;
        background: radial-gradient(circle at top, rgba(255, 255, 255, 0.08), transparent 70%), var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }

      header {
        padding: 1.5rem 1.5rem 1rem;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 1.5rem;
        flex-wrap: wrap;
      }

      .header-branding {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        max-width: min(720px, 100%);
      }

      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 4vw, 2.4rem);
        letter-spacing: 0.08em;
      }

      header p {
        margin: 0;
        opacity: 0.85;
        font-size: 0.95rem;
        line-height: 1.6;
        text-align: left;
      }

      .main-menu-wrapper {
        position: relative;
        margin-left: auto;
      }

      .main-menu-toggle {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 999px;
        color: inherit;
        font-weight: 600;
        letter-spacing: 0.08em;
        padding: 0.6rem 1.2rem;
        cursor: pointer;
        text-transform: uppercase;
        transition: background 160ms ease, color 160ms ease, box-shadow 160ms ease;
      }

      .main-menu-toggle:hover,
      .main-menu-toggle[aria-expanded="true"] {
        background: var(--accent);
        color: #fff;
        box-shadow: 0 12px 30px rgba(217, 109, 40, 0.35);
        border-color: transparent;
      }

      .main-menu {
        position: absolute;
        top: calc(100% + 0.75rem);
        right: 0;
        width: min(280px, 80vw);
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
        padding: 0.75rem;
        z-index: 10;
      }

      main {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 1rem;
        padding: 0 1rem 2rem;
        max-width: 980px;
        width: 100%;
        margin: 0 auto;
      }

      .card {
        background: rgba(15, 22, 32, 0.82);
        border: 1px solid rgba(255, 255, 255, 0.06);
        border-radius: 18px;
        padding: 1.25rem;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.28);
        backdrop-filter: blur(12px);
      }

      nav {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }

      nav button {
        background: rgba(255, 255, 255, 0.04);
        border-radius: 12px;
        border: 1px solid transparent;
        padding: 0.65rem 0.9rem;
        color: inherit;
        font-weight: 600;
        letter-spacing: 0.04em;
        cursor: pointer;
        text-align: left;
        transition: background 180ms ease, border-color 180ms ease, box-shadow 180ms ease;
      }

      nav button.active {
        background: var(--accent);
        border-color: transparent;
        color: #fff;
        box-shadow: 0 8px 20px rgba(217, 109, 40, 0.4);
      }

      nav button:active {
        transform: translateY(1px);
      }

      .encounter-layout {
        display: grid;
        gap: 1rem;
      }

      .encounter-column {
        display: grid;
        gap: 0.85rem;
        padding: 1rem;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .encounter-column header h3 {
        margin: 0;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        font-size: 0.85rem;
        opacity: 0.75;
      }

      .encounter-column header p {
        margin: 0.35rem 0 0;
        line-height: 1.5;
        opacity: 0.8;
        font-size: 0.9rem;
      }

      .party-config {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: flex-end;
      }

      .party-config label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .party-config input {
        background: rgba(0, 0, 0, 0.4);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 0.55rem 0.6rem;
        font-size: 1rem;
        min-width: 4.5rem;
      }

      .encounter-search {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .encounter-filters {
        display: grid;
        gap: 0.45rem;
        padding-top: 0.25rem;
      }

      .encounter-filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .encounter-filter-row label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.8rem;
        opacity: 0.8;
      }

      .encounter-filter-row input {
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
        min-width: 4rem;
      }

      .encounter-role-filters {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .encounter-role-filters label {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.3rem 0.6rem;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.35);
        font-size: 0.8rem;
        opacity: 0.85;
      }

      .encounter-role-filters input {
        accent-color: var(--accent);
      }

      .encounter-search .encounter-show-more {
        align-self: flex-start;
        margin-top: 0.35rem;
        background: transparent;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 0.4rem 0.9rem;
        color: inherit;
        cursor: pointer;
        font-weight: 600;
      }

      .encounter-search input[type="search"] {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        padding: 0.7rem 0.9rem;
        font-size: 1rem;
      }

      .encounter-search-results {
        display: grid;
        gap: 0.6rem;
      }

      .encounter-result {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: center;
        padding: 0.75rem 0.9rem;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.35);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .encounter-result strong {
        display: block;
        font-size: 1rem;
      }

      .encounter-result span {
        display: block;
        font-size: 0.85rem;
        opacity: 0.75;
      }

      .encounter-result button {
        background: var(--accent);
        color: #fff;
        border: none;
        padding: 0.55rem 0.9rem;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        white-space: nowrap;
        box-shadow: 0 10px 22px rgba(217, 109, 40, 0.35);
      }

      .loading-indicator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 0.85rem 1rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        font-size: 0.95rem;
        color: inherit;
      }

      .loading-indicator::before {
        content: "";
        width: 1rem;
        height: 1rem;
        border-radius: 999px;
        border: 2px solid rgba(255, 255, 255, 0.35);
        border-right-color: transparent;
        border-top-color: transparent;
        animation: spin 0.8s linear infinite;
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .roster-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.55rem;
      }

      .roster-empty {
        opacity: 0.7;
        font-size: 0.9rem;
      }

      .roster-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 0.85rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        background: rgba(0, 0, 0, 0.35);
      }

      .roster-meta {
        display: flex;
        flex-direction: column;
        gap: 0.3rem;
      }

      .roster-meta strong {
        font-size: 1rem;
      }

      .roster-meta span {
        font-size: 0.85rem;
        opacity: 0.75;
      }

      .roster-actions {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
      }

      .roster-actions button {
        background: rgba(255, 255, 255, 0.1);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.35rem 0.6rem;
        cursor: pointer;
        font-weight: 600;
      }

      .encounter-roster button {
        margin-top: 0.5rem;
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.4rem 0.75rem;
        font-weight: 600;
        cursor: pointer;
        width: fit-content;
      }

      .roster-count {
        font-variant-numeric: tabular-nums;
        min-width: 2ch;
        text-align: center;
      }

      .encounter-summary {
        display: grid;
        gap: 0.75rem;
        padding: 0.85rem 0.95rem;
        border-radius: 14px;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .difficulty-indicator {
        font-weight: 700;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 0.9rem;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .difficulty-indicator::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #9ca3af;
      }

      .difficulty-indicator[data-difficulty="Easy"]::before {
        background: #31c48d;
      }

      .difficulty-indicator[data-difficulty="Medium"]::before {
        background: #fbbf24;
      }

      .difficulty-indicator[data-difficulty="Hard"]::before {
        background: #f97316;
      }

      .difficulty-indicator[data-difficulty="Deadly"]::before {
        background: #ef4444;
      }

      .threshold-grid {
        display: grid;
        gap: 0.45rem;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      }

      .threshold-grid span {
        display: block;
        font-size: 0.85rem;
        opacity: 0.75;
      }

      .threshold-grid strong {
        display: block;
        font-size: 1rem;
      }

      .encounter-quick-adjust {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .encounter-quick-adjust span {
        opacity: 0.7;
        font-size: 0.85rem;
      }

      .encounter-quick-adjust button {
        background: transparent;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.18);
        padding: 0.35rem 0.75rem;
        color: inherit;
        font-weight: 600;
        cursor: pointer;
      }

      .encounter-footnote {
        font-size: 0.8rem;
        opacity: 0.65;
        line-height: 1.4;
      }

      .initiative-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }

      .initiative-controls button {
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 999px;
        padding: 0.45rem 0.85rem;
        font-weight: 600;
        cursor: pointer;
      }

      .initiative-form {
        display: grid;
        gap: 0.5rem;
      }

      .initiative-form-row {
        display: grid;
        gap: 0.5rem;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .initiative-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .initiative-form input,
      .initiative-form select {
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.6rem 0.7rem;
        font-size: 1rem;
      }

      .initiative-form button[type="submit"] {
        justify-self: start;
        background: var(--accent);
        border: none;
        color: #fff;
        padding: 0.6rem 1.1rem;
        border-radius: 10px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 12px 24px rgba(217, 109, 40, 0.4);
      }

      .initiative-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.6rem;
      }

      .initiative-entry {
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 0.75rem 0.85rem;
        background: rgba(0, 0, 0, 0.35);
        display: grid;
        gap: 0.6rem;
      }

      .initiative-entry.active {
        border-color: rgba(217, 109, 40, 0.55);
        box-shadow: 0 0 0 1px rgba(217, 109, 40, 0.35);
      }

      .initiative-header {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: flex-start;
      }

      .initiative-header strong {
        font-size: 1rem;
      }

      .initiative-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem 0.65rem;
        font-size: 0.8rem;
        opacity: 0.75;
      }

      .initiative-conditions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
      }

      .custom-condition-input {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        padding: 0.25rem 0.5rem;
      }

      .custom-condition-input input {
        background: transparent;
        border: none;
        color: inherit;
        width: 110px;
        font-size: 0.8rem;
        outline: none;
      }

      .custom-condition-input button {
        background: transparent;
        border: none;
        color: var(--accent);
        cursor: pointer;
        font-weight: 600;
        font-size: 0.85rem;
      }

      .condition-chip {
        display: inline-flex;
        align-items: center;
        gap: 0.3rem;
        padding: 0.25rem 0.55rem;
        border-radius: 999px;
        background: rgba(217, 109, 40, 0.22);
        font-size: 0.8rem;
        letter-spacing: 0.05em;
      }

      .condition-chip button {
        background: transparent;
        border: none;
        color: inherit;
        cursor: pointer;
        padding: 0;
        line-height: 1;
      }

      .initiative-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem;
        align-items: center;
      }

      .initiative-actions select,
      .initiative-actions input {
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.45rem 0.6rem;
        font-size: 0.9rem;
      }

      .initiative-actions button {
        background: rgba(255, 255, 255, 0.08);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.35rem 0.6rem;
        cursor: pointer;
        font-size: 0.85rem;
        font-weight: 600;
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }

      section {
        display: none;
      }

      section.active {
        display: block;
      }

      .collapsible-card {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 0.75rem 1rem;
        background: rgba(255, 255, 255, 0.04);
      }

      .collapsible-card summary {
        cursor: pointer;
        list-style: none;
        font-weight: 600;
        letter-spacing: 0.04em;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
      }

      .collapsible-card summary::-webkit-details-marker {
        display: none;
      }

      .collapsible-card[open] {
        background: rgba(255, 255, 255, 0.06);
      }

      .collapsible-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem 0.75rem;
        margin-top: 0.4rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .collapsible-content {
        margin-top: 0.75rem;
        line-height: 1.55;
        font-size: 0.95rem;
        opacity: 0.9;
      }

      .class-accordion {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 0.65rem;
      }

      .class-card,
      .subclass-card {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        padding: 0.75rem 1rem;
      }

      .class-card summary,
      .subclass-card summary {
        cursor: pointer;
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-weight: 600;
        letter-spacing: 0.04em;
      }

      .class-card summary::-webkit-details-marker,
      .subclass-card summary::-webkit-details-marker {
        display: none;
      }

      .class-card[open],
      .subclass-card[open] {
        background: rgba(255, 255, 255, 0.08);
      }

      .class-meta,
      .subclass-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem 1rem;
        margin-top: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.8;
      }

      .class-meta strong,
      .subclass-meta strong {
        font-weight: 600;
      }

      .subclass-group {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.6rem;
      }

      .comparison-note {
        margin-top: 0.6rem;
        font-size: 0.85rem;
        color: #f4b17d;
        line-height: 1.45;
      }

      .comparison-note a {
        color: inherit;
        text-decoration: underline;
      }

      .tag-row {
        display: inline-flex;
        flex-wrap: wrap;
        gap: 0.35rem;
        margin-top: 0.5rem;
      }

      .collapsible-card summary .tag-row {
        margin-top: 0;
      }

      .status {
        display: inline-flex;
        align-items: flex-start;
        gap: 0.65rem;
        margin-top: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.8;
      }

      .status span {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: #ffbe4d;
        display: inline-block;
      }

      .status-details {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .status-details strong {
        font-size: 0.9rem;
      }

      .status-meta {
        font-size: 0.75rem;
        opacity: 0.75;
      }

      .status-meta.warning {
        color: #f97316;
        opacity: 0.95;
        font-weight: 600;
      }

      .status.ready span { background: #31c48d; }
      .status.generating span { background: #ff7849; }

      .model-settings {
        display: none !important;
      }

      .model-settings label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .model-settings select {
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 10px;
        padding: 0.6rem 0.7rem;
        font-size: 1rem;
      }

      .chat-log {
        height: clamp(240px, 40vh, 420px);
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        padding: 1rem;
        border-radius: 14px;
        background: rgba(5, 9, 16, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .message {
        display: flex;
      }

      .message.user {
        justify-content: flex-end;
      }

      .bubble {
        padding: 0.85rem 1rem;
        border-radius: 12px;
        line-height: 1.45;
        box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
      }

      .bubble.user {
        background: rgba(217, 109, 40, 0.18);
        border-top-right-radius: 4px;
      }

      .bubble.assistant {
        background: rgba(255, 255, 255, 0.04);
        border-top-left-radius: 4px;
      }

      .chat-input {
        display: flex;
        gap: 0.75rem;
        margin-top: 1rem;
        flex-wrap: wrap;
      }

      .chat-input textarea {
        flex: 1;
        min-height: 68px;
        resize: vertical;
        border-radius: 12px;
        padding: 0.75rem;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
        font-size: 1rem;
      }

      .chat-input button {
        background: var(--accent);
        border: none;
        color: #fff;
        padding: 0.75rem 1.1rem;
        border-radius: 12px;
        font-weight: 600;
        cursor: pointer;
        min-width: 110px;
        box-shadow: 0 12px 30px rgba(217, 109, 40, 0.4);
        transition: background 160ms ease, transform 160ms ease;
      }

      .chat-input button:disabled {
        opacity: 0.6;
        cursor: wait;
        box-shadow: none;
      }

      .chat-input button:not(:disabled):active {
        transform: translateY(1px);
        background: var(--accent-dark);
      }

      .prompt-toast {
        margin-top: 0.35rem;
        font-size: 0.8rem;
        opacity: 0.75;
        transition: opacity 160ms ease;
      }

      .quick-prompts {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
        margin-top: 1.25rem;
      }

      .quick-prompts-branch {
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        padding: 0.85rem 1rem;
      }

      .quick-prompts-branch summary {
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.6rem;
        list-style: none;
        font-weight: 600;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        opacity: 0.9;
        font-size: 0.95rem;
      }

      .quick-prompts-branch summary::-webkit-details-marker {
        display: none;
      }

      .quick-prompts-branch summary::after {
        content: "";
        width: 0.65rem;
        height: 0.65rem;
        border-right: 2px solid currentColor;
        border-bottom: 2px solid currentColor;
        transform: rotate(-45deg);
        transition: transform 160ms ease;
        flex-shrink: 0;
        opacity: 0.75;
      }

      .quick-prompts-branch[open] summary::after {
        transform: rotate(45deg);
      }

      .quick-prompts-branch[open] summary {
        color: var(--accent);
      }

      .quick-prompts-branch-content {
        margin-top: 0.75rem;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .quick-prompts-description {
        margin: 0;
        font-size: 0.85rem;
        opacity: 0.75;
        line-height: 1.4;
      }

      .reference-grid {
        display: grid;
        gap: 1.25rem;
        margin-top: 1.25rem;
      }

      .reference-card {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 1.1rem 1.25rem;
        display: flex;
        flex-direction: column;
        gap: 0.85rem;
      }

      .reference-card header {
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }

      .reference-card h3 {
        margin: 0;
        font-size: 1.1rem;
        letter-spacing: 0.04em;
      }

      .reference-card p {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.55;
        opacity: 0.85;
      }

      .table-scroll {
        overflow-x: auto;
        border-radius: 12px;
      }

      .reference-table {
        width: 100%;
        border-collapse: collapse;
        min-width: 420px;
        background: rgba(9, 14, 20, 0.65);
      }

      .reference-table caption {
        caption-side: bottom;
        text-align: left;
        font-size: 0.85rem;
        opacity: 0.7;
        padding-top: 0.6rem;
      }

      .reference-table th,
      .reference-table td {
        padding: 0.7rem 0.85rem;
        text-align: left;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        font-size: 0.9rem;
        vertical-align: top;
      }

      .reference-table th {
        font-weight: 600;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        font-size: 0.8rem;
        color: rgba(255, 255, 255, 0.85);
      }

      .reference-table tbody tr:last-child td {
        border-bottom: none;
      }

      .reference-table tbody tr:nth-child(even) {
        background: rgba(255, 255, 255, 0.03);
      }

      .reference-tag {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        background: rgba(217, 109, 40, 0.22);
        color: #ffdcb5;
        border-radius: 999px;
        padding: 0.1rem 0.55rem;
        white-space: nowrap;
      }

      .quick-prompts-buttons {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
      }

      .quick-prompts button {
        background: rgba(255, 255, 255, 0.08);
        border: none;
        color: inherit;
        padding: 0.55rem 0.8rem;
        border-radius: 10px;
        cursor: pointer;
        font-size: 0.85rem;
        text-align: left;
        line-height: 1.35;
        transition: background 150ms ease;
        width: 100%;
      }

      .quick-prompts button:hover {
        background: rgba(255, 255, 255, 0.16);
      }

      @media (max-width: 640px) {
        header {
          padding: 1rem 1rem 0.75rem;
        }

        main {
          padding: 0 0.75rem 1.5rem;
        }

        .card {
          padding: 1rem;
        }

        .status {
          font-size: 0.8rem;
        }

        .main-menu-toggle {
          width: 100%;
          text-align: center;
        }

        .main-menu {
          position: static;
          width: 100%;
          margin-top: 0.75rem;
        }
      }

      details {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 14px;
        padding: 1rem;
        background: rgba(5, 9, 16, 0.65);
      }

      details summary {
        cursor: pointer;
        font-weight: 600;
        letter-spacing: 0.05em;
      }

      .rules-grid {
        display: grid;
        gap: 1rem;
      }

      .setting-controls {
        margin-top: 1.25rem;
      }

      .setting-controls.items-search {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 0.75rem;
      }

      .setting-controls.items-search > * {
        flex: 1 1 220px;
      }

      .settings-grid {
        margin-top: 1.25rem;
        display: grid;
        gap: 1rem;
      }

      .setting-card {
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 16px;
        padding: 1rem 1rem 1.15rem;
        background: rgba(5, 9, 16, 0.7);
      }

      .setting-card summary {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
        cursor: pointer;
        list-style: none;
      }

      .setting-card summary::-webkit-details-marker {
        display: none;
      }

      .setting-card[open] {
        background: rgba(5, 9, 16, 0.82);
      }

      .setting-name {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }

      .setting-name span:first-child {
        font-size: 1.05rem;
        letter-spacing: 0.05em;
      }

      .setting-era {
        font-size: 0.8rem;
        opacity: 0.65;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }

      .setting-body {
        margin-top: 0.85rem;
        display: grid;
        gap: 0.75rem;
      }

      .setting-image {
        border-radius: 12px;
        padding: 1.5rem 1rem;
        background: linear-gradient(135deg, rgba(217, 109, 40, 0.35), rgba(25, 45, 66, 0.85));
        position: relative;
        overflow: hidden;
      }

      .setting-image span {
        display: block;
        font-size: 0.85rem;
        letter-spacing: 0.04em;
        opacity: 0.8;
      }

      .setting-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.45rem 1rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .setting-section {
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        padding-top: 0.75rem;
      }

      .setting-section strong {
        display: block;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        font-size: 0.75rem;
        opacity: 0.8;
        margin-bottom: 0.35rem;
      }

      .setting-section ul {
        margin: 0;
        padding-left: 1.2rem;
      }

      .setting-links {
        display: flex;
        flex-wrap: wrap;
        gap: 0.35rem 0.75rem;
        font-size: 0.85rem;
      }

      .setting-links a {
        color: var(--accent);
        text-decoration: none;
      }

      @media (min-width: 768px) {
        .settings-grid {
          grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }
      }

      .rules-meta {
        margin-top: 0.75rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem 1.25rem;
        font-size: 0.85rem;
        color: rgba(255, 255, 255, 0.85);
      }

      .rules-meta strong {
        font-weight: 600;
        letter-spacing: 0.05em;
        text-transform: uppercase;
      }

      .rules-section {
        margin-top: 0.75rem;
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        padding-top: 0.75rem;
      }

      .rules-section ul,
      .expansion-list ul {
        margin: 0.35rem 0 0;
        padding-left: 1.25rem;
      }

      .setting-links {
        margin-top: 0.35rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .setting-links a {
        color: var(--accent);
        text-decoration: none;
      }

      .setting-links a:hover {
        text-decoration: underline;
      }

      .expansion-list li {
        margin-bottom: 0.2rem;
      }

      .pill {
        display: inline-block;
        background: rgba(217, 109, 40, 0.22);
        color: #ffdcb5;
        border-radius: 999px;
        padding: 0.2rem 0.6rem;
        font-size: 0.75rem;
        letter-spacing: 0.05em;
      }

      .pill.attunement {
        background: rgba(141, 198, 63, 0.25);
        color: #e6ffd1;
      }

      .pill.edition-flag {
        background: rgba(64, 181, 219, 0.25);
        color: #d1f3ff;
      }

      .items-search {
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }

      .items-search input,
      .items-search select {
        width: 100%;
        padding: 0.65rem 0.85rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
      }

      .downtime-tool {
        margin-top: 1.5rem;
        display: grid;
        gap: 1rem;
        padding: 1rem;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.32);
        border: 1px solid rgba(255, 255, 255, 0.12);
      }

      .downtime-tool h3 {
        margin: 0;
        font-size: 1.15rem;
        letter-spacing: 0.04em;
      }

      .downtime-tool p {
        margin: 0;
        font-size: 0.9rem;
        opacity: 0.85;
        line-height: 1.5;
      }

      .downtime-form {
        display: grid;
        gap: 0.85rem;
      }

      .downtime-form label {
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .downtime-form select,
      .downtime-form input {
        width: 100%;
        padding: 0.6rem 0.75rem;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.45);
        color: inherit;
      }

      .downtime-checkboxes {
        display: grid;
        gap: 0.45rem;
      }

      .downtime-checkboxes label {
        display: inline-flex;
        align-items: flex-start;
        gap: 0.5rem;
        font-size: 0.85rem;
        opacity: 0.85;
      }

      .downtime-summary {
        display: grid;
        gap: 0.6rem;
        padding: 0.75rem 0.85rem;
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .downtime-summary strong {
        font-size: 0.95rem;
      }

      .downtime-summary dl {
        display: grid;
        gap: 0.35rem;
        margin: 0;
      }

      .downtime-summary dt {
        font-weight: 600;
        font-size: 0.85rem;
        opacity: 0.75;
      }

      .downtime-summary dd {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.45;
      }

      .downtime-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        align-items: center;
      }

      .downtime-actions button {
        background: rgba(255, 255, 255, 0.12);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.18);
        border-radius: 999px;
        padding: 0.45rem 0.9rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 160ms ease, transform 160ms ease;
      }

      .downtime-actions button:active {
        transform: translateY(1px);
      }

      .downtime-actions button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .item-meta,
      .monster-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 0.4rem 0.75rem;
        align-items: center;
        margin: 0.45rem 0 0;
        font-size: 0.9rem;
        opacity: 0.85;
      }

      .item-meta strong,
      .monster-meta strong {
        font-weight: 600;
      }

      .item-card,
      .monster-card {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 14px;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.04);
      }

      .item-card h4,
      .monster-card h4 {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.5rem;
        font-size: 1rem;
      }

      .item-card p,
      .monster-card p {
        margin: 0.45rem 0 0;
        line-height: 1.5;
        opacity: 0.85;
      }

      .monster-abilities {
        margin: 0.35rem 0 0.15rem;
        padding-left: 1.2rem;
        line-height: 1.5;
        opacity: 0.9;
      }

      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
        min-width: 600px;
      }

      .comparison-table thead th {
        background: #f3f4f6;
        font-weight: 600;
        padding: 0.75rem;
        text-align: left;
      }

      .comparison-table thead th:first-child {
        background: transparent;
      }

      .comparison-table tbody th {
        background: #fafbff;
        width: 16rem;
        font-weight: 600;
        padding: 0.75rem;
        vertical-align: top;
      }

      .comparison-table td {
        border-top: 1px solid rgba(15, 23, 42, 0.1);
        padding: 0.75rem;
        vertical-align: top;
      }

      .comparison-table ul {
        margin: 0.25rem 0 0.5rem;
        padding-left: 1.2rem;
      }

      .comparison-table p {
        margin: 0;
        line-height: 1.5;
      }

      .comparison-table .key-systems {
        background: linear-gradient(135deg, rgba(59, 130, 246, 0.08), rgba(129, 140, 248, 0.08));
        border-radius: 0.35rem;
        padding: 0.5rem 0.75rem;
        display: inline-block;
      }

      .comparison-table .key-systems ul {
        margin: 0.25rem 0 0;
      }

      footer {
        text-align: center;
        padding: 1.5rem 1rem 2rem;
        opacity: 0.7;
        font-size: 0.8rem;
      }

      @media (min-width: 768px) {
        main {
          padding: 0 2rem 2.5rem;
        }

        .reference-grid {
          grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        }

        .encounter-layout {
          grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
        }
      }

      @media (min-width: 1024px) {
        .encounter-layout {
          grid-template-columns: 1.4fr 1fr;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <div class="header-branding">
        <h1>D&D Companion</h1>
        <p>Ask the DM · Browse every edition · Reference gear &amp; loot</p>
      </div>
      <div class="main-menu-wrapper">
        <button
          id="main-menu-toggle"
          class="main-menu-toggle"
          type="button"
          aria-haspopup="true"
          aria-controls="main-menu"
          aria-expanded="false"
        >Main Menu</button>
        <nav
          id="main-menu"
          class="card main-menu"
          role="tablist"
          hidden
        >
          <button
            id="tab-ask"
            class="active"
            role="tab"
            aria-selected="true"
            aria-controls="ask"
            data-target="ask"
          >Ask the DM</button>
          <button
            id="tab-details"
            role="tab"
            aria-selected="false"
            aria-controls="details"
            data-target="details"
          >DM Screen</button>
          <button
            id="tab-encounters"
            role="tab"
            aria-selected="false"
            aria-controls="encounters"
            data-target="encounters"
          >Encounters</button>
          <button
            id="tab-rules"
            role="tab"
            aria-selected="false"
            aria-controls="rules"
            data-target="rules"
          >Rules Compendium</button>
          <button
            id="tab-items"
            role="tab"
            aria-selected="false"
            aria-controls="items"
            data-target="items"
          >Item &amp; Gear Vault</button>
          <button
            id="tab-spells"
            role="tab"
            aria-selected="false"
            aria-controls="spells"
            data-target="spells"
          >Spellbook</button>
          <button
            id="tab-conditions"
            role="tab"
            aria-selected="false"
            aria-controls="conditions"
            data-target="conditions"
          >Condition Codex</button>
          <button
            id="tab-bestiary"
            role="tab"
            aria-selected="false"
            aria-controls="bestiary"
            data-target="bestiary"
          >Bestiary</button>
          <button
            id="tab-compare"
            role="tab"
            aria-selected="false"
            aria-controls="compare"
            data-target="compare"
          >Edition Comparison</button>
        </nav>
      </div>
    </header>

    <main>
      <section id="ask" class="card active" role="tabpanel" tabindex="0" aria-labelledby="tab-ask">
        <h2>Ask the DM</h2>
        <p>
          Greetings Adventurers, I am A.I.D. – the Arcane Intelligence Database, a construct forged from magic and machine to
          serve as your eternal Dungeon Master. Within my circuits lies every spell, tale, and secret ever whispered across
          the realms. Ask, and I shall conjure the knowledge you seek, rules, lore, or legend. Your adventure begins the
          moment you speak.
        </p>
        <div
          class="status"
          id="status"
          role="status"
          aria-live="polite"
          aria-atomic="true"
        >
          <span></span>
          <div class="status-details">
            <strong>Loading</strong>
            <div id="status-meta" class="status-meta" hidden></div>
          </div>
        </div>
        <div class="model-settings" hidden aria-hidden="true">
          <label class="sr-only" for="model-select">Model</label>
          <select id="model-select" name="model-select"></select>
        </div>
        <div
          class="chat-log"
          id="chat-log"
          role="log"
          aria-live="polite"
          aria-relevant="additions text"
          aria-busy="false"
        ></div>
        <div class="chat-input">
          <textarea id="prompt" placeholder="Ask anything about D&D…" aria-label="Ask the DM"></textarea>
          <button id="send" disabled>Send</button>
        </div>
        <div id="prompt-toast" class="prompt-toast" role="status" aria-live="polite" hidden></div>
        <div class="quick-prompts" aria-label="Quick prompts"></div>
      </section>

      <section id="details" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-details" hidden>
        <h2>DM Screen Reference</h2>
        <p>Keep essential adjudication tables within reach. These SRD-friendly summaries cover actions, typical DC benchmarks, overland travel, and common environmental hazards.</p>
        <div id="dm-reference" class="reference-grid" aria-live="polite"></div>
      </section>

      <section id="encounters" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-encounters" hidden>
        <h2>Encounter Workshop</h2>
        <p>Balance combat on the fly with XP math, curated monsters, and a persistent initiative tracker.</p>
        <div class="encounter-layout">
          <article class="encounter-column">
            <header>
              <h3 id="encounter-party-heading">Encounter Builder</h3>
              <p>Set party parameters, add monsters from the bestiary roster, and watch encounter difficulty update in real time.</p>
            </header>
            <div class="party-config" role="group" aria-labelledby="encounter-party-heading">
              <label for="encounter-party-level">Average party level
                <input type="number" id="encounter-party-level" name="encounter-party-level" min="1" max="20" value="5" />
              </label>
              <label for="encounter-party-size">Party size
                <input type="number" id="encounter-party-size" name="encounter-party-size" min="1" max="8" value="4" />
              </label>
            </div>
            <div class="encounter-search">
              <label class="sr-only" for="encounter-monster-query">Search monsters for the encounter roster</label>
              <input type="search" id="encounter-monster-query" placeholder="Search monsters by name, role, or biome" autocomplete="off" />
              <div class="encounter-filters" aria-label="Encounter filters">
                <div class="encounter-filter-row">
                  <label for="encounter-min-diff">Min CR difference
                    <input type="number" id="encounter-min-diff" name="encounter-min-diff" min="0" step="0.5" placeholder="0" />
                  </label>
                  <label for="encounter-max-diff">Max CR difference
                    <input type="number" id="encounter-max-diff" name="encounter-max-diff" min="0" step="0.5" placeholder="Any" />
                  </label>
                </div>
                <div
                  id="encounter-role-filters"
                  class="encounter-role-filters"
                  role="group"
                  aria-label="Filter by combat role"
                ></div>
              </div>
              <div id="encounter-monster-results" class="encounter-search-results" aria-live="polite"></div>
            </div>
            <div class="encounter-roster">
              <h4>Encounter roster</h4>
              <ul id="encounter-roster" class="roster-list" aria-live="polite"></ul>
              <button id="encounter-clear" type="button">Clear roster</button>
            </div>
            <div id="encounter-summary" class="encounter-summary" aria-live="polite"></div>
          </article>
          <article class="encounter-column initiative-column">
            <header>
              <h3 id="initiative-heading">Initiative Tracker</h3>
              <p>Capture turn order, apply relevant conditions, and keep state synced between visits thanks to local storage.</p>
            </header>
            <form id="initiative-form" class="initiative-form" aria-labelledby="initiative-heading">
              <div class="initiative-form-row">
                <label for="initiative-name">Name
                  <input type="text" id="initiative-name" name="initiative-name" placeholder="Creature or character" required />
                </label>
                <label for="initiative-score">Initiative
                  <input type="number" id="initiative-score" name="initiative-score" placeholder="15" />
                </label>
                <label for="initiative-type">Role
                  <select id="initiative-type" name="initiative-type">
                    <option value="PC">PC</option>
                    <option value="Ally">Ally</option>
                    <option value="NPC">NPC</option>
                    <option value="Monster">Monster</option>
                  </select>
                </label>
              </div>
              <button type="submit">Add participant</button>
            </form>
            <div class="initiative-controls" aria-label="Initiative tools">
              <button type="button" id="initiative-sort">Sort by initiative</button>
              <button type="button" id="initiative-next">Advance turn</button>
              <button type="button" id="initiative-clear">Clear tracker</button>
            </div>
            <ul id="initiative-list" class="initiative-list" aria-live="polite"></ul>
          </article>
        </div>
      </section>

      <section id="rules" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-rules" hidden>
        <h2>Rules Compendium</h2>
        <p>Review every major Dungeons &amp; Dragons edition. Each entry includes core rules coverage, iconic subsystems, and the official SRDs or rulebooks to consult for full detail.</p>
        <div class="rules-grid" id="rules-grid"></div>
        <div class="setting-controls items-search" role="search">
          <input type="search" id="setting-query" placeholder="Search settings by name, pitch, or products" aria-label="Search settings" />
          <select id="setting-genre-filter" aria-label="Filter settings by genre">
            <option value="all">All genres</option>
          </select>
        </div>
        <div id="settings-grid" class="settings-grid" aria-live="polite"></div>
      </section>

      <section id="items" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-items" hidden>
        <h2>Item &amp; Gear Vault</h2>
        <p>Search across equipment, magic items, and artifacts spanning multiple editions. Filter by type or rarity and tap an item to review its summary and primary source.</p>
        <div class="items-search">
          <input type="search" id="item-query" placeholder="Search by name, effect, or source" aria-label="Search items" />
          <select id="item-filter" aria-label="Filter rarity">
            <option value="all">All rarities</option>
          </select>
          <select id="attunement-filter" aria-label="Filter attunement requirement">
            <option value="all">All attunement states</option>
            <option value="required">Requires attunement</option>
            <option value="none">No attunement</option>
            <option value="conditional">Conditional or edition-based</option>
          </select>
          <select id="item-type-filter" aria-label="Filter item type">
            <option value="all">All item types</option>
          </select>
          <select id="edition-filter" aria-label="Filter edition availability">
            <option value="all">All editions</option>
          </select>
          <select id="content-tag-filter" aria-label="Filter special content">
            <option value="all">All content</option>
          </select>
        </div>
        <div class="downtime-tool" aria-live="polite">
          <div>
            <h3>Downtime Activity Calculator</h3>
            <p>Estimate downtime costs, workdays, and check guidance for crafting equipment, scribing spells, training new proficiencies, carousing, researching lore, running a business, or advancing a bastion.</p>
          </div>
          <form id="downtime-form" class="downtime-form">
            <label for="downtime-activity">Activity type
              <select id="downtime-activity" name="activity">
                <option value="crafting">Crafting (mundane item)</option>
                <option value="scribing">Scribing a spell</option>
                <option value="training">Training proficiency</option>
                <option value="carousing">Carousing (social downtime)</option>
                <option value="research">Research a lore topic</option>
                <option value="business">Running a business</option>
                <option value="bastion">Bastion turn (2024)</option>
              </select>
            </label>
            <div id="downtime-dynamic-fields"></div>
          </form>
          <div class="downtime-summary" id="downtime-summary">
            <strong>Results will appear here as you enter details.</strong>
            <p style="margin: 0; font-size: 0.85rem; opacity: 0.75;">Downtime math references SRD 5.1 guidelines, the 5e Dungeon Master's Guide, and 2024 bastion previews. Edition tags appear in the copied summary.</p>
          </div>
          <div class="downtime-actions">
            <button type="button" id="downtime-copy" disabled>Copy summary</button>
          </div>
        </div>
        <div id="items-list" style="margin-top: 1rem; display: grid; gap: 0.85rem;"></div>
      </section>

      <section id="spells" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-spells" hidden>
        <h2>Spellbook Archives</h2>
        <p>Explore SRD-friendly spells with quick access to casting details, save mechanics, and reliable sources. Filter by level, school, class, or edition to prep the perfect list.</p>
        <div class="items-search">
          <input type="search" id="spell-query" placeholder="Search spells by name, summary, or tags" aria-label="Search spells" />
          <select id="spell-level-filter" aria-label="Filter spell level">
            <option value="all">All levels</option>
          </select>
          <select id="spell-school-filter" aria-label="Filter spell school">
            <option value="all">All schools</option>
          </select>
          <select id="spell-class-filter" aria-label="Filter spell class">
            <option value="all">All classes</option>
          </select>
          <select id="spell-edition-filter" aria-label="Filter spell edition">
            <option value="all">All editions</option>
          </select>
          <select id="spell-ritual-filter" aria-label="Filter ritual casting">
            <option value="all">All casting modes</option>
            <option value="ritual">Rituals only</option>
            <option value="non">Exclude rituals</option>
          </select>
        </div>
        <div id="spells-list" style="margin-top: 1rem; display: grid; gap: 0.75rem;"></div>
      </section>

      <section id="conditions" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-conditions" hidden>
        <h2>Condition Codex</h2>
        <p>Review the most common conditions adventurers face, from poisoned to paralyzed. Each entry summarizes the mechanical impact and saving throws so you can adjudicate quickly at the table.</p>
        <div class="items-search">
          <input type="search" id="condition-query" placeholder="Search conditions by name" aria-label="Search conditions by name" />
          <select id="condition-duration-filter" aria-label="Filter condition duration">
            <option value="all">All durations</option>
          </select>
          <select id="condition-save-filter" aria-label="Filter required saving throw">
            <option value="all">All saving throws</option>
          </select>
          <input type="search" id="condition-keyword-filter" placeholder="Filter conditions by keyword (movement, senses…)" aria-label="Filter conditions by keyword" />
        </div>
        <div id="conditions-list" style="margin-top: 1rem; display: grid; gap: 0.75rem;"></div>
      </section>

      <section id="bestiary" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-bestiary" hidden>
        <h2>Bestiary</h2>
        <p>Discover iconic creatures with quick access to their tactics, challenge ratings, and SRD-friendly reference links. Filter by role or biome to slot foes into your next encounter.</p>
        <div class="items-search">
          <input type="search" id="monster-query" placeholder="Search by name, ability, or lore" aria-label="Search monsters" />
          <select id="monster-cr-filter" aria-label="Filter challenge rating">
            <option value="all">All challenge ratings</option>
          </select>
          <select id="monster-terrain-filter" aria-label="Filter terrain">
            <option value="all">All terrains</option>
          </select>
          <select id="monster-role-filter" aria-label="Filter combat role">
            <option value="all">All roles</option>
          </select>
        </div>
        <div id="bestiary-list" style="margin-top: 1rem; display: grid; gap: 0.85rem;"></div>
      </section>

      <section id="compare" class="card" role="tabpanel" tabindex="0" aria-labelledby="tab-compare" hidden>
        <h2>Edition Comparison Dashboard</h2>
        <p>Contrast design philosophies, release windows, and key systems at a glance. Use this dashboard to spot how each ruleset approaches combat cadence, narrative support, and supplemental material.</p>
        <div id="comparison-matrix" style="overflow-x: auto;"></div>
      </section>
    </main>

    <footer>
      Built with WebLLM (Gemma-2-2B-it) so your DM helper runs entirely in the browser. Sources reference the SRD/OGL materials for each edition.
    </footer>

    <script type="module">
      const dataLoaders = {
        quickPrompts: () => import("./data/quick-prompts.js").then(module => module.default),
        dmReferences: () => import("./data/dm-references.js").then(module => module.default),
        rulesData: () => import("./data/rules-data.js").then(module => module.default),
        settings: () => import("./data/settings.js").then(module => module.default),
        classes: () => import("./data/classes.js").then(module => module.default),
        items: () => import("./data/items.js").then(module => module.default),
        spells: () => import("./data/spells.js").then(module => module.default),
        conditions: () => import("./data/conditions.js").then(module => module.default),
        xpByCr: () => import("./data/xp-by-cr.js").then(module => module.default),
        monsters: () => import("./data/monsters.js").then(module => module.default)
      };

      const dataCache = new Map();

      const loadData = (key) => {
        if (!dataLoaders[key]) {
          throw new Error(`Unknown data key: ${key}`);
        }
        if (!dataCache.has(key)) {
          dataCache.set(key, dataLoaders[key]());
        }
        return dataCache.get(key);
      };

      const showLoadingIndicator = (container, message) => {
        if (!container) return;
        container.innerHTML = "";
        const indicator = document.createElement("div");
        indicator.className = "loading-indicator";
        indicator.setAttribute("role", "status");
        indicator.setAttribute("aria-live", "polite");
        indicator.textContent = message || "Loading…";
        container.appendChild(indicator);
      };

      const createCell = (cell) => {
        if (typeof cell === "string") {
          return { textContent: cell };
        }
        return cell ?? { textContent: "" };
      };

      const renderReferenceTables = (container, references) => {
        if (!container) return;

        references.forEach(ref => {
          const card = document.createElement("article");
          card.className = "reference-card";

          const header = document.createElement("header");
          const heading = document.createElement("h3");
          heading.textContent = ref.title;
          header.appendChild(heading);

          if (ref.description) {
            const blurb = document.createElement("p");
            blurb.textContent = ref.description;
            header.appendChild(blurb);
          }

          card.appendChild(header);

          const scroll = document.createElement("div");
          scroll.className = "table-scroll";

          const table = document.createElement("table");
          table.className = "reference-table";
          table.setAttribute("data-reference", ref.key);

          if (ref.caption) {
            const caption = document.createElement("caption");
            caption.textContent = ref.caption;
            table.appendChild(caption);
          }

          const thead = document.createElement("thead");
          const headerRow = document.createElement("tr");
          ref.columns.forEach(col => {
            const th = document.createElement("th");
            th.textContent = col;
            headerRow.appendChild(th);
          });
          thead.appendChild(headerRow);
          table.appendChild(thead);

          const tbody = document.createElement("tbody");
          ref.rows.forEach(row => {
            const tr = document.createElement("tr");
            (row.cells ?? []).forEach(cell => {
              const td = document.createElement("td");
              const normalized = createCell(cell);

              if (normalized.tag) {
                const tagEl = document.createElement("span");
                tagEl.className = "reference-tag";
                tagEl.textContent = normalized.tag;
                td.appendChild(tagEl);
              }

              if (normalized.text) {
                if (normalized.tag) {
                  td.appendChild(document.createElement("br"));
                }
                td.appendChild(document.createTextNode(normalized.text));
              } else if (normalized.textContent) {
                td.textContent = normalized.textContent;
              }

              if (Array.isArray(normalized.points) && normalized.points.length > 0) {
                const list = document.createElement("ul");
                list.style.margin = "0.35rem 0 0";
                list.style.paddingLeft = "1.2rem";
                normalized.points.forEach(point => {
                  const li = document.createElement("li");
                  li.textContent = point;
                  list.appendChild(li);
                });
                td.appendChild(list);
              }

              tr.appendChild(td);
            });
            tbody.appendChild(tr);
          });
          table.appendChild(tbody);

          scroll.appendChild(table);
          card.appendChild(scroll);
          container.appendChild(card);
        });
      };

      

      

      

      

      

      

      

      function parseCR(cr) {
        if (typeof cr === "number") return cr;
        if (typeof cr === "string") {
          const trimmed = cr.trim();
          if (trimmed.includes("/")) {
            const [num, denom] = trimmed.split("/").map(Number);
            if (!Number.isNaN(num) && !Number.isNaN(denom) && denom !== 0) {
              return num / denom;
            }
          }
          const numeric = Number(trimmed);
          if (!Number.isNaN(numeric)) {
            return numeric;
          }
        }
        return 0;
      }

      const slugify = (value) => value.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");

      const STORAGE_KEYS = {
        activeSection: "dnd-companion-active-section",
        legacyActiveTab: "dnd-active-tab",
        model: "dnd-companion-llm-model",
        generation: "dnd-companion-generation-settings",
        customConditions: "dnd-companion-custom-conditions"
      };

      let storageAvailable = true;

      const safeStorage = {
        get(key) {
          if (!storageAvailable) return null;
          try {
            return localStorage.getItem(key);
          } catch (error) {
            storageAvailable = false;
            console.warn("Unable to access storage", error);
            return null;
          }
        },
        set(key, value) {
          if (!storageAvailable) return;
          try {
            if (value === null || value === undefined) {
              localStorage.removeItem(key);
            } else {
              localStorage.setItem(key, value);
            }
          } catch (error) {
            storageAvailable = false;
            console.warn("Unable to write to storage", error);
          }
        }
      };

      const readJSONFromStorage = (key, fallback = null) => {
        const raw = safeStorage.get(key);
        if (!raw) return fallback;
        try {
          return JSON.parse(raw);
        } catch (error) {
          console.warn(`Failed to parse stored JSON for ${key}`, error);
          return fallback;
        }
      };

      const writeJSONToStorage = (key, value) => {
        try {
          safeStorage.set(key, JSON.stringify(value));
        } catch (error) {
          console.warn(`Failed to persist JSON for ${key}`, error);
        }
      };

      const clampNumber = (value, min, max) => {
        if (!Number.isFinite(value)) return min;
        return Math.min(Math.max(value, min), max);
      };

      


      

      const referenceContainer = document.getElementById("dm-reference");
      const rulesGrid = document.getElementById("rules-grid");
      let dmReferencesReady = false;

      const ensureDmReferences = async () => {
        if (!referenceContainer || dmReferencesReady) return;
        showLoadingIndicator(referenceContainer, "Loading DM reference tables…");
        try {
          const references = await loadData("dmReferences");
          referenceContainer.innerHTML = "";
          renderReferenceTables(referenceContainer, references);
          dmReferencesReady = true;
        } catch (error) {
          console.error("Failed to load DM references", error);
          showLoadingIndicator(referenceContainer, "Failed to load reference tables");
        }
      };

      const settingQuery = document.getElementById("setting-query");
      const settingGenreSelect = document.getElementById("setting-genre-filter");
      const settingsGrid = document.getElementById("settings-grid");

      const rarityOptions = [
        "Common",
        "Uncommon",
        "Rare",
        "Very Rare",
        "Legendary",
        "Artifact",
        "Standard"
      ];

      const DEFAULT_ITEM_TYPES = [
        "Armor",
        "Bastion Facility",
        "Bastion Project",
        "Bastion Reagent",
        "Bastion Upgrade",
        "Consumable (Alchemical Capsule)",
        "Consumable (Oil)",
        "Consumable (Poison)",
        "Consumable (Potion)",
        "Consumable (Scroll)",
        "Gear",
        "Gear (Weapon)",
        "Magical Tattoo",
        "Rune (Inscription)",
        "Staff",
        "Weapon",
        "Wondrous Item"
      ];

      const spellQuery = document.getElementById("spell-query");
      const spellLevelSelect = document.getElementById("spell-level-filter");
      const spellSchoolSelect = document.getElementById("spell-school-filter");
      const spellClassSelect = document.getElementById("spell-class-filter");
      const spellEditionSelect = document.getElementById("spell-edition-filter");
      const spellRitualSelect = document.getElementById("spell-ritual-filter");
      const spellsList = document.getElementById("spells-list");

      const conditionQuery = document.getElementById("condition-query");
      const conditionDurationSelect = document.getElementById("condition-duration-filter");
      const conditionSaveSelect = document.getElementById("condition-save-filter");
      const conditionKeywordInput = document.getElementById("condition-keyword-filter");
      const conditionsList = document.getElementById("conditions-list");

            // campaign settings render handled in initializeRulesPanel


      let normalizedMonstersPromise;
      const getNormalizedMonsters = async () => {
        if (!normalizedMonstersPromise) {
          normalizedMonstersPromise = Promise.all([
            loadData("monsters"),
            loadData("xpByCr")
          ]).then(([monsters, xpByCr]) =>
            monsters.map(monster => {
              const challengeKey = typeof monster.challenge === "number" ? String(monster.challenge) : monster.challenge;
              const crValue = parseCR(monster.challenge);
              return {
                ...monster,
                id: monster.id || slugify(monster.name),
                xp: monster.xp ?? xpByCr[challengeKey] ?? xpByCr[String(crValue)] ?? 0,
                crValue
              };
            })
          );
        }
        return normalizedMonstersPromise;
      };

      let rulesInitialized = false;
      const initializeRulesPanel = async () => {
        if (rulesInitialized) return;
        rulesInitialized = true;

        if (rulesGrid) {
          showLoadingIndicator(rulesGrid, "Loading edition overviews…");
        }
        if (settingsGrid) {
          showLoadingIndicator(settingsGrid, "Loading campaign settings…");
        }
        const comparisonContainer = document.getElementById("comparison-matrix");
        if (comparisonContainer) {
          showLoadingIndicator(comparisonContainer, "Loading comparison…");
        }

        try {
          const [rulesData, classesByEdition, settingsData] = await Promise.all([
            loadData("rulesData"),
            loadData("classes"),
            loadData("settings")
          ]);

          if (comparisonContainer) {
            comparisonContainer.innerHTML = "";
            const table = document.createElement("table");
            table.className = "comparison-table";

            const headerRow = document.createElement("tr");
            const blank = document.createElement("th");
            blank.scope = "col";
            headerRow.appendChild(blank);
            rulesData.forEach(rule => {
              const th = document.createElement("th");
              th.scope = "col";
              th.textContent = rule.edition;
              headerRow.appendChild(th);
            });

            const thead = document.createElement("thead");
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement("tbody");
            const categories = [
              { key: "tagline", label: "Design Thesis" },
              { key: "released", label: "Release Window" },
              { key: "keySystems", label: "Signature Systems", className: "key-systems" },
              { key: "playstyle", label: "Table Feel & Playstyle" },
              { key: "expansions", label: "Essential Expansions" },
              { key: "adventureHooks", label: "Adventure Hooks" },
              { key: "srds", label: "Primary References" }
            ];

            const renderList = (items, mapper = (item) => item) => {
              const ul = document.createElement("ul");
              items.forEach(item => {
                const li = document.createElement("li");
                li.innerHTML = mapper(item);
                ul.appendChild(li);
              });
              return ul;
            };

            categories.forEach(({ key, label, className }) => {
              const row = document.createElement("tr");
              const heading = document.createElement("th");
              heading.scope = "row";
              heading.textContent = label;
              row.appendChild(heading);

              rulesData.forEach(rule => {
                const td = document.createElement("td");
                if (className) td.className = className;
                const value = rule[key];
                if (Array.isArray(value)) {
                  td.appendChild(renderList(value, item => {
                    if (typeof item === "string") return item;
                    if (item?.url) {
                      return `<a href="${item.url}" target="_blank" rel="noopener">${item.label}</a>`;
                    }
                    return item?.label ?? "";
                  }));
                } else if (value) {
                  td.textContent = value;
                } else {
                  td.textContent = "—";
                  td.style.opacity = "0.65";
                }
                row.appendChild(td);
              });

              tbody.appendChild(row);
            });

            table.appendChild(tbody);
            comparisonContainer.appendChild(table);
          }

          if (rulesGrid) {
            rulesGrid.innerHTML = "";
            rulesData.forEach(rule => {
              const details = document.createElement("details");
              const summary = document.createElement("summary");
              summary.innerHTML = `<span>${rule.edition}</span>`;
              details.appendChild(summary);

              if (rule.tagline) {
                const tagline = document.createElement("p");
                tagline.textContent = rule.tagline;
                tagline.style.marginTop = "0.5rem";
                tagline.style.opacity = "0.85";
                details.appendChild(tagline);
              }

              if (rule.released) {
                const meta = document.createElement("div");
                meta.className = "rules-meta";
                const release = document.createElement("span");
                release.innerHTML = `<strong>Released</strong> ${rule.released}`;
                meta.appendChild(release);
                details.appendChild(meta);
              }

              const systems = document.createElement("div");
              systems.className = "rules-section";
              systems.innerHTML = `<strong>Signature systems</strong>`;
              const ul = document.createElement("ul");
              rule.keySystems.forEach(item => {
                const li = document.createElement("li");
                li.textContent = item;
                ul.appendChild(li);
              });
              systems.appendChild(ul);
              details.appendChild(systems);

              if (rule.playstyle?.length) {
                const playstyle = document.createElement("div");
                playstyle.className = "rules-section";
                playstyle.innerHTML = `<strong>Table feel & playstyle</strong>`;
                const playList = document.createElement("ul");
                rule.playstyle.forEach(item => {
                  const li = document.createElement("li");
                  li.textContent = item;
                  playList.appendChild(li);
                });
                playstyle.appendChild(playList);
                details.appendChild(playstyle);
              }

              const expansions = document.createElement("div");
              expansions.className = "rules-section expansion-list";
              expansions.innerHTML = `<strong>Key rulebooks & expansions</strong>`;
              const ulExp = document.createElement("ul");
              rule.expansions.forEach(item => {
                const li = document.createElement("li");
                li.textContent = item;
                ulExp.appendChild(li);
              });
              expansions.appendChild(ulExp);
              details.appendChild(expansions);

              const classEntries = classesByEdition[rule.editionKey] || [];
              if (classEntries.length) {
                const classSection = document.createElement("div");
                classSection.className = "rules-section";
                const classHeading = document.createElement("strong");
                classHeading.textContent = "Classes & subclass spotlights";
                classHeading.style.display = "block";
                classHeading.style.marginBottom = "0.4rem";
                classSection.appendChild(classHeading);

                const accordion = document.createElement("div");
                accordion.className = "class-accordion";

                classEntries.forEach(cls => {
                  const classDetails = document.createElement("details");
                  classDetails.className = "class-card";

                  const classSummary = document.createElement("summary");
                  const nameSpan = document.createElement("span");
                  nameSpan.textContent = cls.name;
                  classSummary.appendChild(nameSpan);

                  if (cls.hitDie) {
                    const hitDie = document.createElement("span");
                    hitDie.className = "pill";
                    hitDie.textContent = `${cls.hitDie} Hit Die`;
                    classSummary.appendChild(hitDie);
                  }

                  classDetails.appendChild(classSummary);

                  const content = document.createElement("div");
                  content.className = "collapsible-content";

                  if (cls.summary) {
                    const summaryParagraph = document.createElement("p");
                    summaryParagraph.textContent = cls.summary;
                    content.appendChild(summaryParagraph);
                  }

                  const metaRow = document.createElement("div");
                  metaRow.className = "class-meta";
                  if (cls.role) {
                    const roleSpan = document.createElement("span");
                    roleSpan.innerHTML = `<strong>Role:</strong> ${cls.role}`;
                    metaRow.appendChild(roleSpan);
                  }
                  if (cls.primaryAbility) {
                    const abilitySpan = document.createElement("span");
                    abilitySpan.innerHTML = `<strong>Primary ability:</strong> ${cls.primaryAbility}`;
                    metaRow.appendChild(abilitySpan);
                  }
                  if (metaRow.childNodes.length) {
                    content.appendChild(metaRow);
                  }

                  if (Array.isArray(cls.signatureFeatures) && cls.signatureFeatures.length) {
                    const featuresWrapper = document.createElement("div");
                    featuresWrapper.style.marginTop = "0.65rem";
                    const featuresTitle = document.createElement("strong");
                    featuresTitle.textContent = "Signature features";
                    featuresWrapper.appendChild(featuresTitle);

                    const featureList = document.createElement("ul");
                    cls.signatureFeatures.forEach(feature => {
                      const featureItem = document.createElement("li");
                      featureItem.textContent = feature;
                      featureList.appendChild(featureItem);
                    });
                    featuresWrapper.appendChild(featureList);
                    content.appendChild(featuresWrapper);
                  }

                  if (Array.isArray(cls.sources) && cls.sources.length) {
                    const sourcesRow = document.createElement("div");
                    sourcesRow.className = "class-meta";
                    const label = document.createElement("strong");
                    label.textContent = "Sources:";
                    sourcesRow.appendChild(label);

                    cls.sources.forEach((source, index) => {
                      if (index > 0) {
                        sourcesRow.appendChild(document.createTextNode(" · "));
                      }
                      const link = document.createElement("a");
                      link.href = source.url;
                      link.target = "_blank";
                      link.rel = "noopener";
                      link.textContent = source.label;
                      link.style.color = "var(--accent)";
                      link.style.textDecoration = "none";
                      sourcesRow.appendChild(link);
                    });
                    content.appendChild(sourcesRow);
                  }

                  if (cls.comparison?.note) {
                    const comparison = document.createElement("p");
                    comparison.className = "comparison-note";
                    const label = document.createElement("strong");
                    label.textContent = "Cross-edition insight:";
                    comparison.appendChild(label);
                    comparison.appendChild(document.createTextNode(` ${cls.comparison.note}`));
                    if (cls.comparison.link?.url) {
                      comparison.appendChild(document.createTextNode(" "));
                      const link = document.createElement("a");
                      link.href = cls.comparison.link.url;
                      link.target = "_blank";
                      link.rel = "noopener";
                      link.textContent = cls.comparison.link.label || "Read more";
                      comparison.appendChild(link);
                    }
                    content.appendChild(comparison);
                  }

                  if (Array.isArray(cls.subclasses) && cls.subclasses.length) {
                    const subclassGroup = document.createElement("div");
                    subclassGroup.className = "subclass-group";
                    const subHeading = document.createElement("strong");
                    subHeading.textContent = "Subclass highlights";
                    subHeading.style.display = "block";
                    subHeading.style.marginBottom = "0.35rem";
                    subclassGroup.appendChild(subHeading);

                    cls.subclasses.forEach(sub => {
                      const subDetails = document.createElement("details");
                      subDetails.className = "subclass-card";

                      const subSummary = document.createElement("summary");
                      const subName = document.createElement("span");
                      subName.textContent = sub.name;
                      subSummary.appendChild(subName);
                      subDetails.appendChild(subSummary);

                      const subContent = document.createElement("div");
                      subContent.className = "collapsible-content";

                      if (sub.spotlight) {
                        const spotlight = document.createElement("p");
                        spotlight.textContent = sub.spotlight;
                        subContent.appendChild(spotlight);
                      }

                      if (Array.isArray(sub.features) && sub.features.length) {
                        const featureWrap = document.createElement("div");
                        featureWrap.style.marginTop = "0.5rem";
                        const featureHeading = document.createElement("strong");
                        featureHeading.textContent = "Signature moves";
                        featureWrap.appendChild(featureHeading);
                        const subFeatureList = document.createElement("ul");
                        sub.features.forEach(point => {
                          const li = document.createElement("li");
                          li.textContent = point;
                          subFeatureList.appendChild(li);
                        });
                        featureWrap.appendChild(subFeatureList);
                        subContent.appendChild(featureWrap);
                      }

                      if (Array.isArray(sub.sources) && sub.sources.length) {
                        const subSources = document.createElement("div");
                        subSources.className = "subclass-meta";
                        const label = document.createElement("strong");
                        label.textContent = "Sources:";
                        subSources.appendChild(label);
                        sub.sources.forEach((source, index) => {
                          if (index > 0) {
                            subSources.appendChild(document.createTextNode(" · "));
                          }
                          const link = document.createElement("a");
                          link.href = source.url;
                          link.target = "_blank";
                          link.rel = "noopener";
                          link.textContent = source.label;
                          link.style.color = "var(--accent)";
                          link.style.textDecoration = "none";
                          subSources.appendChild(link);
                        });
                        subContent.appendChild(subSources);
                      }

                      if (sub.comparison?.note) {
                        const comparison = document.createElement("p");
                        comparison.className = "comparison-note";
                        const label = document.createElement("strong");
                        label.textContent = "Cross-edition insight:";
                        comparison.appendChild(label);
                        comparison.appendChild(document.createTextNode(` ${sub.comparison.note}`));
                        if (sub.comparison.link?.url) {
                          comparison.appendChild(document.createTextNode(" "));
                          const link = document.createElement("a");
                          link.href = sub.comparison.link.url;
                          link.target = "_blank";
                          link.rel = "noopener";
                          link.textContent = sub.comparison.link.label || "Read more";
                          comparison.appendChild(link);
                        }
                        subContent.appendChild(comparison);
                      }

                      subDetails.appendChild(subContent);
                      subclassGroup.appendChild(subDetails);
                    });

                    content.appendChild(subclassGroup);
                  }

                  classDetails.appendChild(content);
                  accordion.appendChild(classDetails);
                });

                classSection.appendChild(accordion);
                details.appendChild(classSection);
              }

              if (rule.settings?.length) {
                const settingsSection = document.createElement("div");
                settingsSection.className = "rules-section";
                settingsSection.innerHTML = `<strong>Iconic Campaign Settings</strong>`;
                const settingsList = document.createElement("ul");

                rule.settings.forEach(setting => {
                  const li = document.createElement("li");
                  const name = document.createElement("strong");
                  name.textContent = setting.name;
                  li.appendChild(name);

                  if (setting.tone) {
                    li.appendChild(document.createTextNode(` — ${setting.tone}`));
                  }

                  const linkRow = document.createElement("div");
                  linkRow.className = "setting-links";

                  if (setting.source?.url) {
                    const sourceLink = document.createElement("a");
                    sourceLink.href = setting.source.url;
                    sourceLink.target = "_blank";
                    sourceLink.rel = "noopener";
                    sourceLink.textContent = setting.source.label || "Sourcebook";
                    linkRow.appendChild(sourceLink);
                  }

                  const askLink = document.createElement("a");
                  askLink.href = "#ask";
                  askLink.className = "setting-prompt";
                  askLink.dataset.prompt = setting.prompt
                    || `What signature lore should I highlight when running a ${setting.name} campaign for ${rule.edition}?`;
                  askLink.textContent = `Ask the DM about ${setting.name}`;

                  if (linkRow.childNodes.length) {
                    const divider = document.createElement("span");
                    divider.textContent = "·";
                    linkRow.appendChild(divider);
                  }

                  linkRow.appendChild(askLink);
                  li.appendChild(linkRow);

                  settingsList.appendChild(li);
                });

                settingsSection.appendChild(settingsList);
                details.appendChild(settingsSection);
              }

              if (rule.adventureHooks?.length) {
                const hooks = document.createElement("div");
                hooks.className = "rules-section";
                hooks.innerHTML = `<strong>Adventure hook prompts</strong>`;
                const hookList = document.createElement("ul");
                rule.adventureHooks.forEach(item => {
                  const li = document.createElement("li");
                  li.textContent = item;
                  hookList.appendChild(li);
                });
                hooks.appendChild(hookList);
                details.appendChild(hooks);
              }

              const links = document.createElement("div");
              links.className = "rules-section";
              links.innerHTML = `<strong>Primary references & SRDs</strong>`;
              const linkList = document.createElement("ul");
              rule.srds.forEach(srd => {
                const li = document.createElement("li");
                li.innerHTML = `<a href="${srd.url}" target="_blank" rel="noopener">${srd.label}</a>`;
                linkList.appendChild(li);
              });
              links.appendChild(linkList);
              details.appendChild(links);

              rulesGrid.appendChild(details);
            });
          }

          if (settingGenreSelect && settingsGrid) {
            const genres = Array.from(new Set(settingsData.flatMap(setting => setting.genres || []).map(genre => genre?.trim())));
            genres.filter(Boolean).sort((a, b) => a.localeCompare(b)).forEach(genre => {
              const option = document.createElement("option");
              option.value = genre;
              option.textContent = genre;
              settingGenreSelect.appendChild(option);
            });

            const renderSettings = () => {
              const query = settingQuery?.value.toLowerCase().trim() ?? "";
              const genreFilter = settingGenreSelect.value;

              settingsGrid.innerHTML = "";

              const results = settingsData.filter(setting => {
                const normalizedGenres = (setting.genres || []).map(genre => genre.toLowerCase());
                const matchesGenre = genreFilter === "all" || normalizedGenres.includes(genreFilter.toLowerCase());
                const searchableText = [
                  setting.name,
                  setting.era,
                  setting.elevatorPitch,
                  ...(setting.flagshipProducts || []).map(product => `${product.label} ${product.description ?? ""}`),
                  ...(setting.adventureHooks || [])
                ]
                  .filter(Boolean)
                  .join(" ")
                  .toLowerCase();
                const matchesQuery = !query || searchableText.includes(query);
                return matchesGenre && matchesQuery;
              });

              if (!results.length) {
                const empty = document.createElement("p");
                empty.textContent = "No published settings match those filters yet. Try broadening your search.";
                empty.style.opacity = "0.75";
                settingsGrid.appendChild(empty);
                return;
              }

              const getEraYear = (eraText) => {
                if (!eraText) return Number.MAX_SAFE_INTEGER;
                const match = eraText.match(/\d{4}/);
                return match ? Number(match[0]) : Number.MAX_SAFE_INTEGER;
              };

              const sortedResults = [...results].sort((a, b) => {
                const eraA = getEraYear(a.era);
                const eraB = getEraYear(b.era);
                if (eraA !== eraB) return eraA - eraB;
                return (a.name || "").localeCompare(b.name || "");
              });

              sortedResults.forEach(setting => {
                const details = document.createElement("article");
                details.className = "setting-card";

                const header = document.createElement("header");
                const title = document.createElement("h3");
                title.textContent = setting.name;
                header.appendChild(title);

                if (setting.subtitle) {
                  const subtitle = document.createElement("p");
                  subtitle.textContent = setting.subtitle;
                  subtitle.className = "setting-subtitle";
                  header.appendChild(subtitle);
                }

                details.appendChild(header);

                const body = document.createElement("div");
                body.className = "setting-body";

                const image = document.createElement("div");
                image.className = "setting-image";
                if (setting.art?.background) {
                  image.style.background = setting.art.background;
                }
                const caption = document.createElement("span");
                caption.textContent = setting.art?.caption || "Imagery placeholder—describe what your party witnesses.";
                image.appendChild(caption);
                body.appendChild(image);

                if (setting.elevatorPitch) {
                  const pitch = document.createElement("p");
                  pitch.textContent = setting.elevatorPitch;
                  pitch.style.margin = "0";
                  pitch.style.lineHeight = "1.55";
                  pitch.style.opacity = "0.9";
                  body.appendChild(pitch);
                }

                const metaRow = document.createElement("div");
                metaRow.className = "setting-meta";
                if (setting.era) {
                  const eraLabel = document.createElement("span");
                  eraLabel.innerHTML = `<strong>Era:</strong> ${setting.era}`;
                  metaRow.appendChild(eraLabel);
                }
                if (setting.genres?.length) {
                  const toneLabel = document.createElement("span");
                  toneLabel.innerHTML = `<strong>Genres:</strong> ${setting.genres.join(", ")}`;
                  metaRow.appendChild(toneLabel);
                }
                if (metaRow.childNodes.length) {
                  body.appendChild(metaRow);
                }

                if (Array.isArray(setting.flagshipProducts) && setting.flagshipProducts.length) {
                  const flagshipSection = document.createElement("div");
                  flagshipSection.className = "setting-section";
                  const heading = document.createElement("strong");
                  heading.textContent = "Flagship products";
                  flagshipSection.appendChild(heading);

                  const list = document.createElement("ul");
                  setting.flagshipProducts.forEach(product => {
                    const item = document.createElement("li");
                    const link = document.createElement("a");
                    link.href = product.url;
                    link.target = "_blank";
                    link.rel = "noopener";
                    link.textContent = product.label;
                    item.appendChild(link);
                    if (product.description) {
                      item.appendChild(document.createTextNode(` — ${product.description}`));
                    }
                    list.appendChild(item);
                  });
                  flagshipSection.appendChild(list);
                  body.appendChild(flagshipSection);
                }

                if (Array.isArray(setting.officialSources) && setting.officialSources.length) {
                  const linkSection = document.createElement("div");
                  linkSection.className = "setting-section";
                  const label = document.createElement("strong");
                  label.textContent = "Official sources";
                  linkSection.appendChild(label);

                  const linkRow = document.createElement("div");
                  linkRow.className = "setting-links";
                  setting.officialSources.forEach(source => {
                    const link = document.createElement("a");
                    link.href = source.url;
                    link.target = "_blank";
                    link.rel = "noopener";
                    link.textContent = source.label;
                    linkRow.appendChild(link);
                  });
                  linkSection.appendChild(linkRow);
                  body.appendChild(linkSection);
                }

                if (Array.isArray(setting.adventureHooks) && setting.adventureHooks.length) {
                  const hooksSection = document.createElement("div");
                  hooksSection.className = "setting-section";
                  const hooksLabel = document.createElement("strong");
                  hooksLabel.textContent = "Adventure hooks";
                  hooksSection.appendChild(hooksLabel);

                  const hookList = document.createElement("ul");
                  setting.adventureHooks.forEach(hook => {
                    const li = document.createElement("li");
                    li.textContent = hook;
                    hookList.appendChild(li);
                  });
                  hooksSection.appendChild(hookList);
                  body.appendChild(hooksSection);
                }

                details.appendChild(body);
                settingsGrid.appendChild(details);
              });
            };

            settingGenreSelect.addEventListener("change", renderSettings);
            settingQuery?.addEventListener("input", renderSettings);
            renderSettings();
          }
        } catch (error) {
          console.error("Failed to load rules panel data", error);
          if (rulesGrid) {
            showLoadingIndicator(rulesGrid, "Failed to load rules data");
          }
          const comparisonContainer = document.getElementById("comparison-matrix");
          if (comparisonContainer) {
            showLoadingIndicator(comparisonContainer, "Failed to load comparison data");
          }
          if (settingsGrid) {
            showLoadingIndicator(settingsGrid, "Failed to load campaign settings");
          }
        }
      };


      let conditionsInitialized = false;
      const initializeConditionsPanel = async () => {
        if (conditionsInitialized) return;
        if (!conditionsList) {
          conditionsInitialized = true;
          return;
        }
        conditionsInitialized = true;
        showLoadingIndicator(conditionsList, "Loading conditions…");

        try {
          const conditions = await loadData("conditions");
          const durationLabels = {
            ongoing: "Ongoing effects",
            instant: "Instant or until acted",
            special: "Special conditions",
            saveEnds: "Save ends",
            legacy: "Legacy durations"
          };

          if (conditionDurationSelect) {
            const uniqueDurationTags = Array.from(
              new Set(conditions.map(condition => condition.durationTag).filter(Boolean))
            ).sort((a, b) => a.localeCompare(b));
            uniqueDurationTags.forEach(tag => {
              const option = document.createElement("option");
              option.value = tag;
              option.textContent = durationLabels[tag] || tag;
              conditionDurationSelect.appendChild(option);
            });
          }

          if (conditionSaveSelect) {
            const uniqueSaves = Array.from(
              new Set(conditions.map(condition => condition.savingThrow).filter(Boolean))
            ).sort((a, b) => a.localeCompare(b));
            uniqueSaves.forEach(save => {
              const option = document.createElement("option");
              option.value = save;
              option.textContent = save;
              conditionSaveSelect.appendChild(option);
            });
          }

          const renderConditions = () => {
            const nameQuery = conditionQuery?.value.toLowerCase().trim() ?? "";
            const durationFilter = conditionDurationSelect?.value ?? "all";
            const saveFilter = conditionSaveSelect?.value ?? "all";
            const keywordQuery = conditionKeywordInput?.value.toLowerCase().trim() ?? "";

            conditionsList.innerHTML = "";

            const results = conditions.filter(condition => {
              const matchesName = !nameQuery || condition.name.toLowerCase().includes(nameQuery);
              const matchesDuration = durationFilter === "all" || condition.durationTag === durationFilter;
              const matchesSave = saveFilter === "all" || condition.savingThrow === saveFilter;
              const matchesKeyword = !keywordQuery || [
                condition.summary,
                condition.duration,
                condition.savingThrow,
                ...(condition.effects || []),
                ...(condition.keywords || [])
              ]
                .filter(Boolean)
                .some(field => field.toLowerCase().includes(keywordQuery));

              return matchesName && matchesDuration && matchesSave && matchesKeyword;
            });

            if (!results.length) {
              const empty = document.createElement("p");
              empty.textContent = "No conditions match your filters yet. Try a different keyword or duration.";
              empty.style.opacity = "0.75";
              conditionsList.appendChild(empty);
              return;
            }

            results.forEach(condition => {
              const details = document.createElement("details");
              details.className = "collapsible-card";

              const summary = document.createElement("summary");
              summary.innerHTML = `
                <span>${condition.name}</span>
                <span class="tag-row">
                  <span class="pill">${durationLabels[condition.durationTag] || condition.duration}</span>
                  <span class="pill">Save: ${condition.savingThrow}</span>
                </span>
              `;
              details.appendChild(summary);

              const meta = document.createElement("div");
              meta.className = "collapsible-meta";
              meta.innerHTML = `
                <span><strong>Duration:</strong> ${condition.duration}</span>
                <span><strong>Saving Throw:</strong> ${condition.savingThrow}</span>
                <span><strong>Source:</strong> ${condition.source}</span>
              `;
              details.appendChild(meta);

              const body = document.createElement("div");
              body.className = "collapsible-content";
              body.textContent = condition.summary;
              details.appendChild(body);

              if (Array.isArray(condition.effects) && condition.effects.length) {
                const list = document.createElement("ul");
                list.style.margin = "0.5rem 0 0";
                list.style.paddingLeft = "1.25rem";
                condition.effects.forEach(effect => {
                  const li = document.createElement("li");
                  li.textContent = effect;
                  list.appendChild(li);
                });
                details.appendChild(list);
              }

              if (Array.isArray(condition.keywords) && condition.keywords.length) {
                const tagRow = document.createElement("div");
                tagRow.className = "tag-row";
                condition.keywords.forEach(keyword => {
                  const pill = document.createElement("span");
                  pill.className = "pill";
                  pill.textContent = keyword;
                  tagRow.appendChild(pill);
                });
                details.appendChild(tagRow);
              }

              const editionNotes = Array.isArray(condition.editionSpecific)
                ? condition.editionSpecific
                : condition.editionSpecific
                  ? [condition.editionSpecific]
                  : [];

              if (editionNotes.length) {
                const editionBlock = document.createElement("div");
                editionBlock.style.marginTop = "0.5rem";

                const editionHeading = document.createElement("p");
                editionHeading.style.margin = "0";
                editionHeading.innerHTML = "<strong>Edition notes:</strong>";
                editionBlock.appendChild(editionHeading);

                const editionList = document.createElement("ul");
                editionList.style.margin = "0.35rem 0 0";
                editionList.style.paddingLeft = "1.2rem";
                editionNotes.forEach(note => {
                  const li = document.createElement("li");
                  li.textContent = note;
                  editionList.appendChild(li);
                });

                editionBlock.appendChild(editionList);
                details.appendChild(editionBlock);
              }

              conditionsList.appendChild(details);
            });
          };

          conditionQuery?.addEventListener("input", renderConditions);
          conditionDurationSelect?.addEventListener("change", renderConditions);
          conditionSaveSelect?.addEventListener("change", renderConditions);
          conditionKeywordInput?.addEventListener("input", renderConditions);

          renderConditions();
        } catch (error) {
          console.error("Failed to load conditions", error);
          showLoadingIndicator(conditionsList, "Failed to load conditions");
        }
      };


      let bestiaryInitialized = false;
      const initializeBestiaryPanel = async () => {
        if (bestiaryInitialized) return;
        if (!bestiaryList) {
          bestiaryInitialized = true;
          return;
        }
        bestiaryInitialized = true;
        showLoadingIndicator(bestiaryList, "Loading monsters…");

        try {
          const monsters = await getNormalizedMonsters();

          if (monsterCRSelect) {
            const uniqueCRs = Array.from(new Set(monsters.map(monster => monster.challenge)))
              .filter(Boolean)
              .sort((a, b) => parseCR(a) - parseCR(b));
            uniqueCRs.forEach(cr => {
              const option = document.createElement("option");
              option.value = cr;
              option.textContent = `CR ${cr}`;
              monsterCRSelect.appendChild(option);
            });
          }

          if (monsterTerrainSelect) {
            const uniqueTerrains = Array.from(
              new Set(monsters.flatMap(monster => monster.terrain || []))
            )
              .filter(Boolean)
              .sort((a, b) => a.localeCompare(b));
            uniqueTerrains.forEach(terrain => {
              const option = document.createElement("option");
              option.value = terrain;
              option.textContent = terrain;
              monsterTerrainSelect.appendChild(option);
            });
          }

          if (monsterRoleSelect) {
            const uniqueRoles = Array.from(
              new Set(monsters.flatMap(monster => monster.role || []))
            )
              .filter(Boolean)
              .sort((a, b) => a.localeCompare(b));
            uniqueRoles.forEach(role => {
              const option = document.createElement("option");
              option.value = role;
              option.textContent = role;
              monsterRoleSelect.appendChild(option);
            });
          }

          const renderMonsters = () => {
            const query = monsterQuery?.value.toLowerCase().trim() ?? "";
            const crFilter = monsterCRSelect?.value ?? "all";
            const terrainFilter = monsterTerrainSelect?.value ?? "all";
            const roleFilter = monsterRoleSelect?.value ?? "all";

            bestiaryList.innerHTML = "";

            const results = monsters.filter(monster => {
              const searchableFields = [
                monster.name,
                monster.overview,
                monster.creatureType,
                monster.alignment,
                monster.size,
                ...(monster.signatureAbilities || []),
                ...(monster.terrain || []),
                ...(monster.role || [])
              ]
                .filter(Boolean)
                .map(field => field.toLowerCase());

              const matchesQuery = !query || searchableFields.some(field => field.includes(query));
              const matchesCR = crFilter === "all" || String(monster.challenge) === crFilter;
              const matchesTerrain = terrainFilter === "all" || (monster.terrain || []).includes(terrainFilter);
              const matchesRole = roleFilter === "all" || (monster.role || []).includes(roleFilter);
              return matchesQuery && matchesCR && matchesTerrain && matchesRole;
            });

            if (!results.length) {
              const empty = document.createElement("p");
              empty.textContent = "No monsters match those filters. Try broadening your search or removing a filter.";
              empty.style.opacity = "0.75";
              bestiaryList.appendChild(empty);
              return;
            }

            results.forEach(monster => {
              const card = document.createElement("article");
              card.className = "monster-card";
              const abilityList = (monster.signatureAbilities || [])
                .map(ability => `<li>${ability}</li>`)
                .join("");
              const sourceLinks = (monster.sources || [])
                .map(source => `<a href="${source.url}" target="_blank" rel="noopener">${source.label}</a>`)
                .join(", ");

              card.innerHTML = `
                <h4>
                  ${monster.name}
                  <span class="pill">CR ${monster.challenge}</span>
                </h4>
                <div class="monster-meta">
                  <span><strong>Size:</strong> ${monster.size}</span>
                  <span><strong>Type:</strong> ${monster.creatureType}</span>
                  <span><strong>Alignment:</strong> ${monster.alignment}</span>
                  <span><strong>Role:</strong> ${(monster.role || []).join(", ") || "—"}</span>
                  <span><strong>Terrain:</strong> ${(monster.terrain || []).join(", ") || "—"}</span>
                </div>
                <p>${monster.overview}</p>
                ${(monster.signatureAbilities || []).length ? `<p><strong>Signature abilities & tactics</strong></p>` : ""}
                ${(monster.signatureAbilities || []).length ? `<ul class="monster-abilities">${abilityList}</ul>` : ""}
                <p style="font-size: 0.85rem; opacity: 0.7;"><strong>Sources:</strong> ${sourceLinks}</p>
              `;

              bestiaryList.appendChild(card);
            });
          };

          monsterQuery?.addEventListener("input", renderMonsters);
          monsterCRSelect?.addEventListener("change", renderMonsters);
          monsterTerrainSelect?.addEventListener("change", renderMonsters);
          monsterRoleSelect?.addEventListener("change", renderMonsters);

          renderMonsters();
        } catch (error) {
          console.error("Failed to load monsters", error);
          showLoadingIndicator(bestiaryList, "Failed to load monsters");
        }
      };


      let encountersInitialized = false;
      const initializeEncountersPanel = async () => {
        if (encountersInitialized) return;
        if (
          !encounterPartyLevelInput ||
          !encounterPartySizeInput ||
          !encounterSearchInput ||
          !encounterResultsContainer ||
          !encounterRosterList ||
          !encounterSummaryContainer ||
          !encounterClearButton ||
          !initiativeForm ||
          !initiativeList ||
          !initiativeSortButton ||
          !initiativeClearButton ||
          !initiativeNextButton
        ) {
          encountersInitialized = true;
          return;
        }

        encountersInitialized = true;
        showLoadingIndicator(encounterResultsContainer, "Loading encounter tools…");
        showLoadingIndicator(encounterRosterList, "Loading encounter tools…");
        showLoadingIndicator(encounterSummaryContainer, "Loading encounter tools…");
        showLoadingIndicator(initiativeList, "Loading encounter tools…");

        try {
          const [monsters, conditions] = await Promise.all([
            getNormalizedMonsters(),
            loadData("conditions")
          ]);

          encounterResultsContainer.innerHTML = "";
          encounterRosterList.innerHTML = "";
          encounterSummaryContainer.innerHTML = "";
          initiativeList.innerHTML = "";

          const monsterLookup = new Map(monsters.map(monster => [monster.id, monster]));

          const storedCustomConditions = readJSONFromStorage(STORAGE_KEYS.customConditions, []);
          let recentCustomConditions = Array.isArray(storedCustomConditions)
            ? storedCustomConditions
                .filter(item => typeof item === "string")
                .map(item => item.trim())
                .filter(Boolean)
            : [];

          recentCustomConditions = recentCustomConditions.filter((value, index, array) =>
            array.findIndex(item => item.toLowerCase() === value.toLowerCase()) === index
          );

          const persistCustomConditions = () => {
            writeJSONToStorage(STORAGE_KEYS.customConditions, recentCustomConditions);
          };

          const addCustomConditionToHistory = (label) => {
            const trimmed = label.trim();
            if (!trimmed) return;
            const lower = trimmed.toLowerCase();
            recentCustomConditions = recentCustomConditions.filter(item => item.toLowerCase() !== lower);
            recentCustomConditions.unshift(trimmed);
            if (recentCustomConditions.length > 10) {
              recentCustomConditions = recentCustomConditions.slice(0, 10);
            }
            persistCustomConditions();
          };

          const applyCustomCondition = (participant, label) => {
            const trimmed = label.trim();
            if (!trimmed) return false;
            const lower = trimmed.toLowerCase();
            if (!participant.conditions.some(condition => condition.toLowerCase() === lower)) {
              participant.conditions.push(trimmed);
            }
            addCustomConditionToHistory(trimmed);
            return true;
          };

          const PARTY_XP_THRESHOLDS = {
            1: { easy: 25, medium: 50, hard: 75, deadly: 100 },
            2: { easy: 50, medium: 100, hard: 150, deadly: 200 },
            3: { easy: 75, medium: 150, hard: 225, deadly: 400 },
            4: { easy: 125, medium: 250, hard: 375, deadly: 500 },
            5: { easy: 250, medium: 500, hard: 750, deadly: 1100 },
            6: { easy: 300, medium: 600, hard: 900, deadly: 1400 },
            7: { easy: 350, medium: 750, hard: 1100, deadly: 1700 },
            8: { easy: 450, medium: 900, hard: 1400, deadly: 2100 },
            9: { easy: 550, medium: 1100, hard: 1600, deadly: 2400 },
            10: { easy: 600, medium: 1200, hard: 1900, deadly: 2800 },
            11: { easy: 800, medium: 1600, hard: 2400, deadly: 3600 },
            12: { easy: 1000, medium: 2000, hard: 3000, deadly: 4500 },
            13: { easy: 1100, medium: 2200, hard: 3400, deadly: 5100 },
            14: { easy: 1250, medium: 2500, hard: 3800, deadly: 5700 },
            15: { easy: 1400, medium: 2800, hard: 4300, deadly: 6400 },
            16: { easy: 1600, medium: 3200, hard: 4800, deadly: 7200 },
            17: { easy: 2000, medium: 3900, hard: 5900, deadly: 8800 },
            18: { easy: 2100, medium: 4200, hard: 6300, deadly: 9500 },
            19: { easy: 2400, medium: 4900, hard: 7300, deadly: 10900 },
            20: { easy: 2800, medium: 5700, hard: 8500, deadly: 12700 }
          };

          const MULTIPLIER_STEPS = [
            { max: 1, label: "Single monster", multiplier: 1 },
            { max: 2, label: "Pair of monsters", multiplier: 1.5 },
            { max: 6, label: "3–6 monsters", multiplier: 2 },
            { max: 10, label: "7–10 monsters", multiplier: 2.5 },
            { max: 14, label: "11–14 monsters", multiplier: 3 },
            { max: Infinity, label: "15+ monsters", multiplier: 4 }
          ];

          const numberFormatter = new Intl.NumberFormat("en-US");
          const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

          const encounterState = {
            partyLevel: clamp(Math.floor(Number(encounterPartyLevelInput.value) || 1), 1, 20),
            partySize: clamp(Math.floor(Number(encounterPartySizeInput.value) || 4), 1, 8),
            monsters: []
          };

          encounterPartyLevelInput.value = String(encounterState.partyLevel);
          encounterPartySizeInput.value = String(encounterState.partySize);

          const ENCOUNTER_PAGE_SIZE = 8;
          const encounterSearchState = {
            page: 1,
            selectedRoles: new Set()
          };

          const parseDifferenceInput = (input) => {
            if (!input) return null;
            const raw = input.value.trim();
            if (raw === "") return null;
            const value = Number(raw);
            if (!Number.isFinite(value) || value < 0) return null;
            return value;
          };

          const resetEncounterPage = () => {
            encounterSearchState.page = 1;
          };

          const renderRoleFilters = () => {
            if (!encounterRoleFiltersContainer) return;
            encounterRoleFiltersContainer.innerHTML = "";
            const roleValues = Array.from(
              new Set(
                monsters.flatMap(monster => monster.role || [])
              )
            )
              .filter(Boolean)
              .sort((a, b) => a.localeCompare(b));

            if (!roleValues.length) {
              return;
            }

            roleValues.forEach(role => {
              const label = document.createElement("label");
              const checkbox = document.createElement("input");
              checkbox.type = "checkbox";
              checkbox.value = role;
              checkbox.checked = encounterSearchState.selectedRoles.has(role.toLowerCase());
              checkbox.id = `encounter-role-${slugify(role)}`;
              label.appendChild(checkbox);
              const text = document.createElement("span");
              text.textContent = role;
              label.appendChild(text);
              encounterRoleFiltersContainer.appendChild(label);
            });
          };

          const formatXP = (value) => numberFormatter.format(Math.max(0, Math.round(value || 0)));

          const ensureRosterSorted = () => {
            encounterState.monsters.sort((a, b) => {
              const monsterA = monsterLookup.get(a.id);
              const monsterB = monsterLookup.get(b.id);
              const crDiff = (monsterB?.crValue ?? 0) - (monsterA?.crValue ?? 0);
              if (crDiff !== 0) return crDiff;
              return (monsterB?.xp ?? 0) - (monsterA?.xp ?? 0);
            });
          };

          const getMultiplierInfo = (count, partySize) => {
            if (count <= 0) {
              return {
                multiplier: 1,
                baseLabel: "No monsters",
                appliedLabel: "No monsters",
                adjustment: "Add creatures to calculate encounter difficulty"
              };
            }

            let index = MULTIPLIER_STEPS.findIndex(step => count <= step.max);
            if (index === -1) index = MULTIPLIER_STEPS.length - 1;
            const baseIndex = index;

            if (partySize <= 2 && index < MULTIPLIER_STEPS.length - 1) {
              index += 1;
            } else if (partySize >= 6 && index > 0) {
              index -= 1;
            }

            const adjustment =
              partySize <= 2
                ? "Adjusted up for a small party"
                : partySize >= 6
                  ? "Adjusted down for a large party"
                  : "Standard party size";

            return {
              multiplier: MULTIPLIER_STEPS[index].multiplier,
              baseLabel: MULTIPLIER_STEPS[baseIndex].label,
              appliedLabel: MULTIPLIER_STEPS[index].label,
              adjustment
            };
          };

          const getPartyThresholds = () => {
            const template = PARTY_XP_THRESHOLDS[encounterState.partyLevel] || PARTY_XP_THRESHOLDS[20];
            return {
              easy: template.easy * encounterState.partySize,
              medium: template.medium * encounterState.partySize,
              hard: template.hard * encounterState.partySize,
              deadly: template.deadly * encounterState.partySize
            };
          };

          const renderEncounterRoster = () => {
            encounterRosterList.innerHTML = "";

            if (!encounterState.monsters.length) {
              const empty = document.createElement("li");
              empty.className = "roster-empty";
              empty.textContent = "No creatures added yet. Use the search above to populate your encounter.";
              encounterRosterList.appendChild(empty);
              return;
            }

            encounterState.monsters.forEach(entry => {
              const monster = monsterLookup.get(entry.id);
              if (!monster) return;

              const item = document.createElement("li");
              item.className = "roster-row";
              item.dataset.id = entry.id;

              const meta = document.createElement("div");
              meta.className = "roster-meta";

              const title = document.createElement("strong");
              title.textContent = monster.name;
              meta.appendChild(title);

              const detail = document.createElement("span");
              detail.textContent = `CR ${monster.challenge} · ${formatXP(monster.xp)} XP each`;
              meta.appendChild(detail);

              const total = document.createElement("span");
              total.textContent = `${formatXP((monster.xp || 0) * entry.count)} XP total`;
              meta.appendChild(total);

              item.appendChild(meta);

              const actions = document.createElement("div");
              actions.className = "roster-actions";

              const decrease = document.createElement("button");
              decrease.type = "button";
              decrease.dataset.action = "decrease";
              decrease.textContent = "–";
              decrease.setAttribute("aria-label", `Remove one ${monster.name}`);
              actions.appendChild(decrease);

              const count = document.createElement("span");
              count.className = "roster-count";
              count.textContent = String(entry.count);
              actions.appendChild(count);

              const increase = document.createElement("button");
              increase.type = "button";
              increase.dataset.action = "increase";
              increase.textContent = "+";
              increase.setAttribute("aria-label", `Add another ${monster.name}`);
              actions.appendChild(increase);

              const remove = document.createElement("button");
              remove.type = "button";
              remove.dataset.action = "remove";
              remove.textContent = "Remove";
              remove.setAttribute("aria-label", `Remove ${monster.name} from the encounter`);
              actions.appendChild(remove);

              item.appendChild(actions);
              encounterRosterList.appendChild(item);
            });
          };

          const nudgeEncounter = (direction) => {
            if (!encounterState.monsters.length) return;
            ensureRosterSorted();
            const sorted = encounterState.monsters
              .map(entry => ({ ...entry }))
              .sort((a, b) => {
                const xpA = monsterLookup.get(a.id)?.xp ?? 0;
                const xpB = monsterLookup.get(b.id)?.xp ?? 0;
                return xpB - xpA;
              });

            const target = sorted[0];
            if (!target) return;

            const original = encounterState.monsters.find(entry => entry.id === target.id);
            if (!original) return;

            if (direction < 0) {
              original.count -= 1;
              if (original.count <= 0) {
                encounterState.monsters = encounterState.monsters.filter(entry => entry.id !== original.id);
              }
            } else {
              original.count += 1;
            }

            ensureRosterSorted();
            renderEncounterRoster();
            renderEncounterSummary();
            renderEncounterSearch();
          };

          const renderEncounterSummary = () => {
            encounterSummaryContainer.innerHTML = "";

            const totalMonsters = encounterState.monsters.reduce((sum, entry) => sum + entry.count, 0);
            const thresholds = getPartyThresholds();
            const multiplierInfo = getMultiplierInfo(totalMonsters, encounterState.partySize);

            let baseXP = 0;
            encounterState.monsters.forEach(entry => {
              const monster = monsterLookup.get(entry.id);
              if (!monster) return;
              baseXP += (monster.xp || 0) * entry.count;
            });

            const adjustedXP = totalMonsters ? Math.round(baseXP * multiplierInfo.multiplier) : 0;

            let difficulty = "Trivial";
            if (totalMonsters === 0) {
              difficulty = "Trivial";
            } else if (adjustedXP >= thresholds.deadly) {
              difficulty = "Deadly";
            } else if (adjustedXP >= thresholds.hard) {
              difficulty = "Hard";
            } else if (adjustedXP >= thresholds.medium) {
              difficulty = "Medium";
            } else if (adjustedXP >= thresholds.easy) {
              difficulty = "Easy";
            }

            const indicator = document.createElement("div");
            indicator.className = "difficulty-indicator";
            indicator.dataset.difficulty = difficulty;
            indicator.textContent =
              totalMonsters === 0
                ? "No monsters selected"
                : `${difficulty === "Trivial" ? "Trivial (below easy)" : `${difficulty} encounter`}`;
            encounterSummaryContainer.appendChild(indicator);

            const xpSummary = document.createElement("p");
            xpSummary.textContent = `Base XP ${formatXP(baseXP)} · Adjusted XP ${formatXP(adjustedXP)}`;
            encounterSummaryContainer.appendChild(xpSummary);

            const thresholdGrid = document.createElement("div");
            thresholdGrid.className = "threshold-grid";
            [
              ["Easy", thresholds.easy],
              ["Medium", thresholds.medium],
              ["Hard", thresholds.hard],
              ["Deadly", thresholds.deadly]
            ].forEach(([label, value]) => {
              const cell = document.createElement("div");
              const caption = document.createElement("span");
              caption.textContent = label;
              const amount = document.createElement("strong");
              amount.textContent = formatXP(value);
              cell.appendChild(caption);
              cell.appendChild(amount);
              thresholdGrid.appendChild(cell);
            });
            encounterSummaryContainer.appendChild(thresholdGrid);

            if (totalMonsters > 0) {
              const quickAdjust = document.createElement("div");
              quickAdjust.className = "encounter-quick-adjust";
              const label = document.createElement("span");
              label.textContent = "Quick adjust:";
              quickAdjust.appendChild(label);

              const easierButton = document.createElement("button");
              easierButton.type = "button";
              easierButton.dataset.adjust = "easier";
              easierButton.textContent = "Ease encounter";
              quickAdjust.appendChild(easierButton);

              const harderButton = document.createElement("button");
              harderButton.type = "button";
              harderButton.dataset.adjust = "harder";
              harderButton.textContent = "Raise stakes";
              quickAdjust.appendChild(harderButton);

              encounterSummaryContainer.appendChild(quickAdjust);
            }

            const multiplierText = Number.isInteger(multiplierInfo.multiplier)
              ? multiplierInfo.multiplier.toString()
              : multiplierInfo.multiplier.toFixed(1);

            const footnote = document.createElement("p");
            footnote.className = "encounter-footnote";
            footnote.textContent = `XP multiplier ×${multiplierText} (${multiplierInfo.appliedLabel}; ${multiplierInfo.adjustment}).`;
            encounterSummaryContainer.appendChild(footnote);
          };

          const renderEncounterSearch = () => {
            if (!encounterResultsContainer) return;
            encounterResultsContainer.innerHTML = "";
            const query = encounterSearchInput.value.toLowerCase().trim();
            const targetCR = encounterState.partyLevel;
            const minDiffRaw = parseDifferenceInput(encounterMinDiffInput);
            const maxDiffRaw = parseDifferenceInput(encounterMaxDiffInput);
            let minDiff = minDiffRaw;
            let maxDiff = maxDiffRaw;
            if (minDiff !== null && maxDiff !== null && maxDiff < minDiff) {
              maxDiff = minDiff;
            }

            const filtered = monsters
              .filter(monster => {
                const diff = Math.abs((monster.crValue ?? parseCR(monster.challenge)) - targetCR);
                if (minDiff !== null && diff < minDiff) return false;
                if (maxDiff !== null && diff > maxDiff) return false;
                if (encounterSearchState.selectedRoles.size) {
                  const roles = (monster.role || []).map(role => role.toLowerCase());
                  const matchesRole = Array.from(encounterSearchState.selectedRoles).some(role => roles.includes(role));
                  if (!matchesRole) return false;
                }
                if (!query) return true;
                const haystack = [
                  monster.name,
                  monster.creatureType,
                  monster.alignment,
                  monster.overview,
                  ...(monster.role || []),
                  ...(monster.terrain || [])
                ]
                  .filter(Boolean)
                  .join(" ")
                  .toLowerCase();
                return haystack.includes(query);
              })
              .sort((a, b) => {
                const diff = Math.abs((a.crValue ?? parseCR(a.challenge)) - targetCR)
                  - Math.abs((b.crValue ?? parseCR(b.challenge)) - targetCR);
                if (diff !== 0) return diff;
                return a.name.localeCompare(b.name);
              });

            if (!filtered.length) {
              encounterSearchState.page = 1;
              const empty = document.createElement("p");
              empty.className = "roster-empty";
              empty.textContent = "No monsters match those filters. Broaden the CR range or uncheck some roles.";
              encounterResultsContainer.appendChild(empty);
              return;
            }

            const totalPages = Math.max(1, Math.ceil(filtered.length / ENCOUNTER_PAGE_SIZE));
            encounterSearchState.page = Math.min(encounterSearchState.page, totalPages);
            const maxVisible = encounterSearchState.page * ENCOUNTER_PAGE_SIZE;
            const results = filtered.slice(0, maxVisible);

            results.forEach(monster => {
              const result = document.createElement("div");
              result.className = "encounter-result";

              const text = document.createElement("div");
              const title = document.createElement("strong");
              title.textContent = monster.name;
              text.appendChild(title);

              const subtitle = document.createElement("span");
              subtitle.textContent = `CR ${monster.challenge} · ${formatXP(monster.xp)} XP`;
              text.appendChild(subtitle);

              const tags = document.createElement("span");
              tags.textContent = `${(monster.role || []).join(", ") || "Unknown role"} · ${(monster.terrain || []).join(", ") || "Any biome"}`;
              tags.style.opacity = "0.65";
              tags.style.fontSize = "0.8rem";
              text.appendChild(tags);

              result.appendChild(text);

              const button = document.createElement("button");
              button.type = "button";
              button.dataset.monsterId = monster.id;
              const existing = encounterState.monsters.find(entry => entry.id === monster.id);
              button.textContent = existing ? "Add another" : "Add";
              result.appendChild(button);

              encounterResultsContainer.appendChild(result);
            });

            if (filtered.length > results.length) {
              const remaining = filtered.length - results.length;
              const showMore = document.createElement("button");
              showMore.type = "button";
              showMore.className = "encounter-show-more";
              showMore.dataset.action = "show-more";
              showMore.textContent = remaining > ENCOUNTER_PAGE_SIZE
                ? `Show more (${remaining} more)`
                : `Show remaining ${remaining}`;
              encounterResultsContainer.appendChild(showMore);
            }
          };

          const addMonsterToEncounter = (id) => {
            const monster = monsterLookup.get(id);
            if (!monster) return;
            const existing = encounterState.monsters.find(entry => entry.id === id);
            if (existing) {
              existing.count += 1;
            } else {
              encounterState.monsters.push({ id, count: 1 });
            }
            ensureRosterSorted();
            renderEncounterRoster();
            renderEncounterSummary();
            renderEncounterSearch();
          };

          encounterPartyLevelInput.addEventListener("input", () => {
            const parsed = Math.floor(Number(encounterPartyLevelInput.value));
            if (Number.isNaN(parsed)) return;
            encounterState.partyLevel = clamp(parsed, 1, 20);
            encounterPartyLevelInput.value = String(encounterState.partyLevel);
            renderEncounterSummary();
            resetEncounterPage();
            renderEncounterSearch();
          });

          encounterPartySizeInput.addEventListener("input", () => {
            const parsed = Math.floor(Number(encounterPartySizeInput.value));
            if (Number.isNaN(parsed)) return;
            encounterState.partySize = clamp(parsed, 1, 8);
            encounterPartySizeInput.value = String(encounterState.partySize);
            renderEncounterSummary();
          });

          encounterSearchInput.addEventListener("input", () => {
            resetEncounterPage();
            renderEncounterSearch();
          });

          encounterMinDiffInput?.addEventListener("input", () => {
            resetEncounterPage();
            renderEncounterSearch();
          });

          encounterMaxDiffInput?.addEventListener("input", () => {
            resetEncounterPage();
            renderEncounterSearch();
          });

          encounterRoleFiltersContainer?.addEventListener("change", (event) => {
            const checkbox = event.target.closest("input[type=\"checkbox\"]");
            if (!checkbox) return;
            const value = checkbox.value?.toLowerCase();
            if (!value) return;
            if (checkbox.checked) {
              encounterSearchState.selectedRoles.add(value);
            } else {
              encounterSearchState.selectedRoles.delete(value);
            }
            resetEncounterPage();
            renderEncounterSearch();
          });

          encounterResultsContainer.addEventListener("click", (event) => {
            const addButton = event.target.closest("button[data-monster-id]");
            if (addButton) {
              addMonsterToEncounter(addButton.dataset.monsterId);
              return;
            }
            const showMoreButton = event.target.closest("button[data-action=\"show-more\"]");
            if (showMoreButton) {
              encounterSearchState.page += 1;
              renderEncounterSearch();
            }
          });

          encounterRosterList.addEventListener("click", (event) => {
            const button = event.target.closest("button[data-action]");
            if (!button) return;
            const item = event.target.closest("li[data-id]");
            if (!item) return;
            const entry = encounterState.monsters.find(mon => mon.id === item.dataset.id);
            if (!entry) return;

            if (button.dataset.action === "increase") {
              entry.count += 1;
            } else if (button.dataset.action === "decrease") {
              entry.count -= 1;
              if (entry.count <= 0) {
                encounterState.monsters = encounterState.monsters.filter(mon => mon.id !== entry.id);
              }
            } else if (button.dataset.action === "remove") {
              encounterState.monsters = encounterState.monsters.filter(mon => mon.id !== entry.id);
            }

            ensureRosterSorted();
            renderEncounterRoster();
            renderEncounterSummary();
            renderEncounterSearch();
          });

          encounterSummaryContainer.addEventListener("click", (event) => {
            const button = event.target.closest("button[data-adjust]");
            if (!button) return;
            if (button.dataset.adjust === "easier") {
              nudgeEncounter(-1);
            } else if (button.dataset.adjust === "harder") {
              nudgeEncounter(1);
            }
          });

          encounterClearButton.addEventListener("click", () => {
            if (!encounterState.monsters.length) return;
            encounterState.monsters = [];
            renderEncounterRoster();
            renderEncounterSummary();
            resetEncounterPage();
            renderEncounterSearch();
          });

          renderRoleFilters();
          ensureRosterSorted();
          renderEncounterRoster();
          renderEncounterSummary();
          renderEncounterSearch();

          const INIT_STORAGE_KEY = "dnd-companion-initiative-v1";
          const initiativeNameInput = document.getElementById("initiative-name");
          const initiativeScoreInput = document.getElementById("initiative-score");
          const initiativeTypeSelect = document.getElementById("initiative-type");

          const createId = () =>
            `${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 7)}`;

          const normalizeParticipant = (participant) => ({
            id: participant.id || createId(),
            name: participant.name || "Unnamed",
            initiative: typeof participant.initiative === "number"
              ? participant.initiative
              : Number(participant.initiative) || 0,
            type: participant.type || "PC",
            conditions: Array.isArray(participant.conditions)
              ? participant.conditions.filter(Boolean)
              : []
          });

          let initiativeState = { participants: [], activeId: null };

          try {
            const stored = localStorage.getItem(INIT_STORAGE_KEY);
            if (stored) {
              const parsed = JSON.parse(stored);
              if (Array.isArray(parsed?.participants)) {
                initiativeState.participants = parsed.participants.map(normalizeParticipant);
                if (parsed.activeId && initiativeState.participants.some(p => p.id === parsed.activeId)) {
                  initiativeState.activeId = parsed.activeId;
                }
              }
            }
          } catch (error) {
            console.warn("Failed to load initiative tracker state", error);
          }

          const saveInitiativeState = () => {
            try {
              localStorage.setItem(
                INIT_STORAGE_KEY,
                JSON.stringify({
                  participants: initiativeState.participants,
                  activeId: initiativeState.activeId
                })
              );
            } catch (error) {
              console.warn("Unable to persist initiative state", error);
            }
          };

          const buildConditionSelector = () => {
            const select = document.createElement("select");
            select.className = "condition-selector";
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Add condition…";
            select.appendChild(placeholder);
            if (recentCustomConditions.length) {
              const customGroup = document.createElement("optgroup");
              customGroup.label = "Recent custom";
              recentCustomConditions.forEach(name => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                customGroup.appendChild(option);
              });
              select.appendChild(customGroup);
            }
            const baseGroup = document.createElement("optgroup");
            baseGroup.label = "SRD conditions";
            conditions.forEach(condition => {
              const option = document.createElement("option");
              option.value = condition.name;
              option.textContent = condition.name;
              baseGroup.appendChild(option);
            });
            select.appendChild(baseGroup);
            return select;
          };

          const renderInitiative = () => {
            initiativeList.innerHTML = "";

            if (!initiativeState.participants.length) {
              const empty = document.createElement("li");
              empty.className = "roster-empty";
              empty.textContent = "No participants yet. Add adventurers, allies, or foes to start tracking initiative.";
              initiativeList.appendChild(empty);
              return;
            }

            initiativeState.participants.forEach(participant => {
              const item = document.createElement("li");
              item.className = "initiative-entry";
              item.dataset.id = participant.id;
              if (participant.id === initiativeState.activeId) {
                item.classList.add("active");
              }

              const header = document.createElement("div");
              header.className = "initiative-header";

              const info = document.createElement("div");
              const name = document.createElement("strong");
              name.textContent = participant.name;
              info.appendChild(name);

              const meta = document.createElement("div");
              meta.className = "initiative-meta";
              meta.innerHTML = `
                <span>Initiative ${participant.initiative ?? "—"}</span>
                <span>${participant.type}</span>
              `;
              info.appendChild(meta);
              header.appendChild(info);

              const headerActions = document.createElement("div");
              headerActions.className = "initiative-actions";

              const activateButton = document.createElement("button");
              activateButton.type = "button";
              activateButton.dataset.action = "activate";
              activateButton.textContent = "Set active";
              activateButton.setAttribute("aria-label", `Set ${participant.name} as the active turn`);
              headerActions.appendChild(activateButton);

              const removeButton = document.createElement("button");
              removeButton.type = "button";
              removeButton.dataset.action = "remove";
              removeButton.textContent = "Remove";
              removeButton.setAttribute("aria-label", `Remove ${participant.name} from initiative`);
              headerActions.appendChild(removeButton);

              header.appendChild(headerActions);
              item.appendChild(header);

              if (participant.conditions.length) {
                const conditionsRow = document.createElement("div");
                conditionsRow.className = "initiative-conditions";
                participant.conditions.forEach(condition => {
                  const chip = document.createElement("span");
                  chip.className = "condition-chip";
                  chip.dataset.condition = condition;
                  chip.textContent = condition;
                  const removeChip = document.createElement("button");
                  removeChip.type = "button";
                  removeChip.className = "condition-remove";
                  removeChip.setAttribute("aria-label", `Remove ${condition} from ${participant.name}`);
                  removeChip.textContent = "×";
                  chip.appendChild(removeChip);
                  conditionsRow.appendChild(chip);
                });
                item.appendChild(conditionsRow);
              }

              const actions = document.createElement("div");
              actions.className = "initiative-actions";

              const initiativeInput = document.createElement("input");
              initiativeInput.type = "number";
              initiativeInput.className = "initiative-score-input";
              initiativeInput.value = participant.initiative ?? "";
              initiativeInput.placeholder = "Init";
              initiativeInput.dataset.id = participant.id;
              initiativeInput.setAttribute("aria-label", `Initiative score for ${participant.name}`);
              actions.appendChild(initiativeInput);

              const conditionSelect = buildConditionSelector();
              conditionSelect.dataset.id = participant.id;
              actions.appendChild(conditionSelect);

              const customCondition = document.createElement("div");
              customCondition.className = "custom-condition-input";
              const customInput = document.createElement("input");
              customInput.type = "text";
              customInput.placeholder = "Custom";
              customInput.dataset.id = participant.id;
              customInput.setAttribute("aria-label", `Custom condition for ${participant.name}`);
              const customButton = document.createElement("button");
              customButton.type = "button";
              customButton.className = "custom-condition-add";
              customButton.dataset.id = participant.id;
              customButton.textContent = "Add";
              customButton.setAttribute("aria-label", `Add custom condition to ${participant.name}`);
              customCondition.appendChild(customInput);
              customCondition.appendChild(customButton);
              actions.appendChild(customCondition);

              const upButton = document.createElement("button");
              upButton.type = "button";
              upButton.dataset.action = "move-up";
              upButton.textContent = "▲";
              upButton.setAttribute("aria-label", `Move ${participant.name} up`);
              actions.appendChild(upButton);

              const downButton = document.createElement("button");
              downButton.type = "button";
              downButton.dataset.action = "move-down";
              downButton.textContent = "▼";
              downButton.setAttribute("aria-label", `Move ${participant.name} down`);
              actions.appendChild(downButton);

              item.appendChild(actions);
              initiativeList.appendChild(item);
            });
          };

          const moveParticipant = (id, delta) => {
            const index = initiativeState.participants.findIndex(p => p.id === id);
            if (index === -1) return;
            const newIndex = index + delta;
            if (newIndex < 0 || newIndex >= initiativeState.participants.length) return;
            const [participant] = initiativeState.participants.splice(index, 1);
            initiativeState.participants.splice(newIndex, 0, participant);
          };

          const sortParticipantsByInitiative = () => {
            initiativeState.participants.sort((a, b) => {
              if ((b.initiative ?? 0) !== (a.initiative ?? 0)) {
                return (b.initiative ?? 0) - (a.initiative ?? 0);
              }
              return a.name.localeCompare(b.name);
            });
          };

          initiativeForm.addEventListener("submit", (event) => {
            event.preventDefault();
            const name = initiativeNameInput.value.trim();
            if (!name) return;
            const initiativeScore = Math.floor(Number(initiativeScoreInput.value));
            const participant = {
              id: createId(),
              name,
              initiative: Number.isNaN(initiativeScore) ? 0 : initiativeScore,
              type: initiativeTypeSelect.value || "PC",
              conditions: []
            };
            initiativeState.participants.push(participant);
            if (!initiativeState.activeId) {
              initiativeState.activeId = participant.id;
            }
            sortParticipantsByInitiative();
            renderInitiative();
            saveInitiativeState();
            initiativeForm.reset();
            initiativeNameInput.focus();
          });

          initiativeList.addEventListener("change", (event) => {
            const item = event.target.closest("li[data-id]");
            if (!item) return;
            const participant = initiativeState.participants.find(p => p.id === item.dataset.id);
            if (!participant) return;

            if (event.target.matches(".initiative-score-input")) {
              const value = Math.floor(Number(event.target.value));
              participant.initiative = Number.isNaN(value) ? 0 : value;
              renderInitiative();
              saveInitiativeState();
            } else if (event.target.matches(".condition-selector")) {
              const condition = event.target.value;
              event.target.value = "";
              const trimmed = condition.trim();
              if (!trimmed) return;
              const lower = trimmed.toLowerCase();
              const isStandard = conditions.some(entry => entry.name.toLowerCase() === lower);
              if (!participant.conditions.some(name => name.toLowerCase() === lower)) {
                participant.conditions.push(trimmed);
              }
              if (!isStandard) {
                addCustomConditionToHistory(trimmed);
              }
              renderInitiative();
              saveInitiativeState();
              return;
            }
          });

          initiativeList.addEventListener("click", (event) => {
            const item = event.target.closest("li[data-id]");
            if (!item) return;
            const participant = initiativeState.participants.find(p => p.id === item.dataset.id);
            if (!participant) return;

            if (event.target.classList.contains("custom-condition-add")) {
              const wrapper = event.target.closest(".custom-condition-input");
              const input = wrapper?.querySelector("input");
              const value = input?.value ?? "";
              if (applyCustomCondition(participant, value)) {
                renderInitiative();
                saveInitiativeState();
              }
              if (input) {
                input.value = "";
                input.focus();
              }
              return;
            }

            if (event.target.classList.contains("condition-remove")) {
              const condition = event.target.parentElement?.dataset.condition;
              if (condition) {
                participant.conditions = participant.conditions.filter(name => name !== condition);
                renderInitiative();
                saveInitiativeState();
              }
              return;
            }

            const button = event.target.closest("button[data-action]");
            if (!button) return;

            if (button.dataset.action === "remove") {
              initiativeState.participants = initiativeState.participants.filter(p => p.id !== participant.id);
              if (initiativeState.activeId === participant.id) {
                initiativeState.activeId = initiativeState.participants[0]?.id ?? null;
              }
            } else if (button.dataset.action === "activate") {
              initiativeState.activeId = participant.id;
            } else if (button.dataset.action === "move-up") {
              moveParticipant(participant.id, -1);
            } else if (button.dataset.action === "move-down") {
              moveParticipant(participant.id, 1);
            }

            renderInitiative();
            saveInitiativeState();
          });

          initiativeList.addEventListener("keydown", (event) => {
            if (!event.target.matches(".custom-condition-input input")) return;
            if (event.key !== "Enter") return;
            event.preventDefault();
            const item = event.target.closest("li[data-id]");
            if (!item) return;
            const participant = initiativeState.participants.find(p => p.id === item.dataset.id);
            if (!participant) return;
            const value = event.target.value ?? "";
            if (applyCustomCondition(participant, value)) {
              renderInitiative();
              saveInitiativeState();
            }
            event.target.value = "";
          });

          initiativeSortButton.addEventListener("click", () => {
            sortParticipantsByInitiative();
            renderInitiative();
            saveInitiativeState();
          });

          initiativeClearButton.addEventListener("click", () => {
            if (!initiativeState.participants.length) return;
            if (!confirm("Clear all participants from the initiative tracker?")) return;
            initiativeState = { participants: [], activeId: null };
            renderInitiative();
            saveInitiativeState();
          });

          initiativeNextButton.addEventListener("click", () => {
            if (!initiativeState.participants.length) return;
            if (!initiativeState.activeId) {
              initiativeState.activeId = initiativeState.participants[0].id;
            } else {
              const currentIndex = initiativeState.participants.findIndex(p => p.id === initiativeState.activeId);
              const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % initiativeState.participants.length;
              initiativeState.activeId = initiativeState.participants[nextIndex].id;
            }
            renderInitiative();
            saveInitiativeState();
          });

          renderInitiative();
        } catch (error) {
          console.error("Failed to load encounter tools", error);
          showLoadingIndicator(encounterResultsContainer, "Failed to load encounter data");
          showLoadingIndicator(encounterRosterList, "Failed to load encounter data");
          showLoadingIndicator(encounterSummaryContainer, "Failed to load encounter data");
          showLoadingIndicator(initiativeList, "Failed to load encounter data");
        }
      };


      let itemsInitialized = false;
      const initializeItemsPanel = async () => {
        if (itemsInitialized) return;
        if (!itemsList) {
          itemsInitialized = true;
          return;
        }
        itemsInitialized = true;
        showLoadingIndicator(itemsList, "Loading items…");

        try {
          const items = await loadData("items");

          ensureRarityOptions();
          buildItemFilters(items);

          if (editionSelect) {
            const uniqueEditions = Array.from(new Set(items.map(item => item.edition))).sort((a, b) => a.localeCompare(b));
            uniqueEditions.forEach(edition => {
              const option = document.createElement("option");
              option.value = edition;
              option.textContent = edition;
              editionSelect.appendChild(option);
            });
          }

          if (contentTagSelect) {
            const uniqueTags = Array.from(
              new Set(items.flatMap(item => item.tags || []).filter(Boolean))
            ).sort((a, b) => a.localeCompare(b));
            uniqueTags.forEach(tag => {
              const option = document.createElement("option");
              option.value = tag;
              option.textContent = tag;
              contentTagSelect.appendChild(option);
            });
          }

          const renderItems = () => {
            const query = itemQuery?.value.toLowerCase().trim() ?? "";
            const rarity = raritySelect?.value ?? "all";
            const attunement = attunementSelect?.value ?? "all";
            const type = typeSelect?.value ?? "all";
            const edition = editionSelect?.value ?? "all";
            const contentTag = contentTagSelect?.value ?? "all";

            itemsList.innerHTML = "";
            const results = items.filter(item => {
              const matchesQuery =
                !query ||
                [item.name, item.description, item.source, item.type, item.edition, item.attunement, item.notes, item.cost]
                  .filter(Boolean)
                  .some(field => field.toLowerCase().includes(query));
              const matchesRarity = rarity === "all" || item.rarity === rarity;
              const matchesAttunement = attunement === "all" || item.attunementTag === attunement;
              const matchesType = type === "all" || item.type === type;
              const matchesEdition = edition === "all" || item.edition === edition;
              const normalizedTags = item.tags || [];
              const matchesTag = contentTag === "all" || normalizedTags.includes(contentTag);
              return matchesQuery && matchesRarity && matchesAttunement && matchesType && matchesEdition && matchesTag;
            });

            if (!results.length) {
              const empty = document.createElement("p");
              empty.textContent = "No items match your filters yet. Try a different search term.";
              empty.style.opacity = "0.75";
              itemsList.appendChild(empty);
              return;
            }

            results.forEach(item => {
              const card = document.createElement("article");
              card.className = "item-card";
              const badgePieces = [`<span class=\"pill\">${item.rarity}</span>`];
              if (item.attunementTag === "required") {
                badgePieces.push('<span class="pill attunement">Requires attunement</span>');
              } else if (item.attunementTag === "conditional") {
                badgePieces.push('<span class="pill attunement">Conditional attunement</span>');
              }
              if (item.editionSpecific) {
                badgePieces.push('<span class="pill edition-flag">Edition variants</span>');
              }

              card.innerHTML = `
                <h4>${item.name}</h4>
                <div class="item-meta">
                  <span><strong>Type:</strong> ${item.type}</span>
                  <span><strong>Edition:</strong> ${item.edition}</span>
                  ${badgePieces.join(" ")}
                </div>
                <p>${item.description}</p>
                <p><strong>Attunement:</strong> ${item.attunement}</p>
                <p><strong>Cost:</strong> ${item.cost}</p>
                ${item.constructionTime ? `<p><strong>Construction:</strong> ${item.constructionTime}</p>` : ""}
                ${item.tierRequirement ? `<p><strong>Tier Requirement:</strong> ${item.tierRequirement}</p>` : ""}
                <p><strong>Notes:</strong> ${item.notes}</p>
                ${item.tags?.length ? `<div class="tag-row">${item.tags.map(tag => `<span class=\"pill\">${tag}</span>`).join(" ")}</div>` : ""}
                <p style="font-size: 0.85rem; opacity: 0.7;"><strong>Source:</strong> ${item.source}</p>
              `;
              itemsList.appendChild(card);
            });
          };

          itemQuery?.addEventListener("input", renderItems);
          raritySelect?.addEventListener("change", renderItems);
          attunementSelect?.addEventListener("change", renderItems);
          typeSelect?.addEventListener("change", renderItems);
          editionSelect?.addEventListener("change", renderItems);
          contentTagSelect?.addEventListener("change", renderItems);

          renderItems();
        } catch (error) {
          console.error("Failed to load items", error);
          showLoadingIndicator(itemsList, "Failed to load items");
        }
      };


      let spellsInitialized = false;
      const initializeSpellsPanel = async () => {
        if (spellsInitialized) return;
        if (!spellsList) {
          spellsInitialized = true;
          return;
        }
        spellsInitialized = true;
        showLoadingIndicator(spellsList, "Loading spells…");

        try {
          const rawSpells = await loadData("spells");
          const spells = rawSpells.map(spell => {
            const combinedTags = Array.from(
              new Set([
                ...(spell.tags || []),
                ...(spell.keywords || []),
                ...(spell.sourceTags || []),
                spell.ritual ? "Ritual" : null
              ].filter(Boolean))
            );

            return {
              ...spell,
              componentsText: spell.componentsText ?? spell.components ?? "—",
              save: spell.save ?? spell.savingThrow ?? "",
              source: spell.source ?? "",
              edition: spell.edition ?? "Unspecified",
              classes: Array.isArray(spell.classes) ? spell.classes : [],
              ritual: spell.ritual === true,
              tags: combinedTags
            };
          });
          const formatSpellLevel = (level) => (Number(level) === 0 ? "Cantrip" : `Level ${level}`);

          if (spellLevelSelect) {
            const uniqueLevels = Array.from(new Set(spells.map(spell => spell.level))).sort((a, b) => a - b);
            uniqueLevels.forEach(level => {
              const option = document.createElement("option");
              option.value = String(level);
              option.textContent = formatSpellLevel(level);
              spellLevelSelect.appendChild(option);
            });
          }

          if (spellSchoolSelect) {
            const uniqueSchools = Array.from(new Set(spells.map(spell => spell.school))).sort((a, b) => a.localeCompare(b));
            uniqueSchools.forEach(school => {
              const option = document.createElement("option");
              option.value = school;
              option.textContent = school;
              spellSchoolSelect.appendChild(option);
            });
          }

          if (spellClassSelect) {
            const uniqueClasses = Array.from(new Set(spells.flatMap(spell => spell.classes || []))).sort((a, b) => a.localeCompare(b));
            uniqueClasses.forEach(cls => {
              const option = document.createElement("option");
              option.value = cls;
              option.textContent = cls;
              spellClassSelect.appendChild(option);
            });
          }

          if (spellEditionSelect) {
            const uniqueEditions = Array.from(new Set(spells.map(spell => spell.edition))).sort((a, b) => a.localeCompare(b));
            uniqueEditions.forEach(edition => {
              const option = document.createElement("option");
              option.value = edition;
              option.textContent = edition;
              spellEditionSelect.appendChild(option);
            });
          }

          const renderSpells = () => {
            const query = spellQuery?.value.toLowerCase().trim() ?? "";
            const levelFilter = spellLevelSelect?.value ?? "all";
            const schoolFilter = spellSchoolSelect?.value ?? "all";
            const classFilter = spellClassSelect?.value ?? "all";
            const editionFilter = spellEditionSelect?.value ?? "all";
            const ritualFilter = spellRitualSelect?.value ?? "all";

            spellsList.innerHTML = "";
            const results = spells.filter(spell => {
              const matchesQuery =
                !query ||
                [
                  spell.name,
                  spell.summary,
                  spell.componentsText,
                  spell.source,
                  spell.edition,
                  spell.classes?.join(", "),
                  ...(spell.tags || [])
                ]
                  .filter(Boolean)
                  .some(field => field.toLowerCase().includes(query));
              const matchesLevel = levelFilter === "all" || String(spell.level) === levelFilter;
              const matchesSchool = schoolFilter === "all" || spell.school === schoolFilter;
              const matchesClass = classFilter === "all" || (spell.classes || []).includes(classFilter);
              const matchesEdition = editionFilter === "all" || spell.edition === editionFilter;
              const matchesRitual =
                ritualFilter === "all"
                || (ritualFilter === "ritual" && spell.ritual)
                || (ritualFilter === "non" && !spell.ritual);
              return matchesQuery && matchesLevel && matchesSchool && matchesClass && matchesEdition && matchesRitual;
            });

            if (!results.length) {
              const empty = document.createElement("p");
              empty.textContent = "No spells match your filters yet. Try broadening your search.";
              empty.style.opacity = "0.75";
              spellsList.appendChild(empty);
              return;
            }

            results.forEach(spell => {
              const card = document.createElement("article");
              card.className = "spell-card";
              const tags = (spell.tags || []).map(tag => `<span class=\"pill\">${tag}</span>`).join(" ");
              card.innerHTML = `
                <header>
                  <h4>${spell.name}</h4>
                  <div class="spell-meta">
                    <span>${formatSpellLevel(spell.level)}</span>
                    <span>${spell.school}</span>
                    <span>${spell.edition}</span>
                  </div>
                </header>
                <p>${spell.summary}</p>
                <dl class="spell-details">
                  <div><dt>Casting time</dt><dd>${spell.castingTime}</dd></div>
                  <div><dt>Range</dt><dd>${spell.range}</dd></div>
                  <div><dt>Components</dt><dd>${spell.componentsText}</dd></div>
                  <div><dt>Duration</dt><dd>${spell.duration}</dd></div>
                </dl>
                ${spell.save ? `<p><strong>Save:</strong> ${spell.save}</p>` : ""}
                ${tags ? `<div class=\"tag-row\">${tags}</div>` : ""}
                <p style="font-size: 0.85rem; opacity: 0.7;"><strong>Source:</strong> ${spell.source}</p>
              `;
              spellsList.appendChild(card);
            });
          };

          spellQuery?.addEventListener("input", renderSpells);
          spellLevelSelect?.addEventListener("change", renderSpells);
          spellSchoolSelect?.addEventListener("change", renderSpells);
          spellClassSelect?.addEventListener("change", renderSpells);
          spellEditionSelect?.addEventListener("change", renderSpells);
          spellRitualSelect?.addEventListener("change", renderSpells);

          renderSpells();
        } catch (error) {
          console.error("Failed to load spells", error);
          showLoadingIndicator(spellsList, "Failed to load spells");
        }
      };

      const quickPromptsContainer = document.querySelector(".quick-prompts");
      let quickPromptsReady = false;

      const ensureQuickPrompts = async () => {
        if (!quickPromptsContainer || quickPromptsReady) return;
        showLoadingIndicator(quickPromptsContainer, "Loading quick prompts…");
        try {
          const quickPrompts = await loadData("quickPrompts");
          quickPromptsContainer.innerHTML = "";

          quickPrompts.forEach(group => {
            const branch = document.createElement("details");
            branch.className = "quick-prompts-branch";

            const summary = document.createElement("summary");
            summary.textContent = group.theme;
            branch.appendChild(summary);

            const content = document.createElement("div");
            content.className = "quick-prompts-branch-content";

            if (group.description) {
              const description = document.createElement("p");
              description.className = "quick-prompts-description";
              description.textContent = group.description;
              content.appendChild(description);
            }

            const buttonGrid = document.createElement("div");
            buttonGrid.className = "quick-prompts-buttons";

            group.prompts.forEach(promptItem => {
              const button = document.createElement("button");
              button.type = "button";
              button.dataset.prompt = promptItem.prompt;
              button.textContent = promptItem.label;
              buttonGrid.appendChild(button);
            });

            content.appendChild(buttonGrid);
            branch.appendChild(content);
            if (!quickPromptsContainer.children.length) {
              branch.open = true;
            }
            quickPromptsContainer.appendChild(branch);
          });

          quickPromptsReady = true;
        } catch (error) {
          console.error("Failed to load quick prompts", error);
          showLoadingIndicator(quickPromptsContainer, "Failed to load quick prompts");
        }
      };

      const panelInitializers = {
        ask: ensureQuickPrompts,
        details: ensureDmReferences,
        rules: initializeRulesPanel,
        items: initializeItemsPanel,
        spells: initializeSpellsPanel,
        conditions: initializeConditionsPanel,
        bestiary: initializeBestiaryPanel,
        encounters: initializeEncountersPanel,
        compare: initializeRulesPanel
      };

      const mainMenuToggle = document.getElementById("main-menu-toggle");
      const mainMenu = document.getElementById("main-menu");
      const mainMenuWrapper = document.querySelector(".main-menu-wrapper");

      const isMainMenuOpen = () => Boolean(mainMenu && !mainMenu.hasAttribute("hidden"));

      const openMainMenu = () => {
        if (!mainMenu || !mainMenuToggle) return;
        mainMenu.removeAttribute("hidden");
        mainMenuToggle.setAttribute("aria-expanded", "true");
      };

      const closeMainMenu = () => {
        if (!mainMenu || !mainMenuToggle) return;
        if (!isMainMenuOpen()) return;
        mainMenu.setAttribute("hidden", "");
        mainMenuToggle.setAttribute("aria-expanded", "false");
      };

      mainMenuToggle?.addEventListener("click", (event) => {
        event.stopPropagation();
        if (isMainMenuOpen()) {
          closeMainMenu();
        } else {
          openMainMenu();
        }
      });

      document.addEventListener("click", (event) => {
        if (!isMainMenuOpen()) return;
        if (!mainMenuWrapper?.contains(event.target)) {
          closeMainMenu();
        }
      });

      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape" && isMainMenuOpen()) {
          event.preventDefault();
          closeMainMenu();
          mainMenuToggle?.focus();
        }
      });

      const tabs = Array.from(document.querySelectorAll('nav [role="tab"]'));
      const panels = Array.from(document.querySelectorAll('main [role="tabpanel"]'));

      const storeActiveSection = (targetId) => {
        if (!targetId) return;
        safeStorage.set(STORAGE_KEYS.activeSection, targetId);
      };

      const getStoredActiveSection = () => {
        return (
          safeStorage.get(STORAGE_KEYS.activeSection)
          ?? safeStorage.get(STORAGE_KEYS.legacyActiveTab)
        );
      };

      const activateTab = (tab, { focusPanel = false, persist = false } = {}) => {
        if (!tab) return;
        const targetId = tab.getAttribute("aria-controls");
        const targetPanel = panels.find(panel => panel.id === targetId);

        tabs.forEach(btn => {
          const isSelected = btn === tab;
          btn.classList.toggle("active", isSelected);
          btn.setAttribute("aria-selected", isSelected ? "true" : "false");
          btn.tabIndex = isSelected ? 0 : -1;
        });

        panels.forEach(panel => {
          const isActive = panel === targetPanel;
          panel.classList.toggle("active", isActive);
          if (isActive) {
            panel.removeAttribute("hidden");
            if (focusPanel && typeof panel.focus === "function") {
              panel.focus();
            }
          } else {
            panel.setAttribute("hidden", "");
          }
        });

        panelInitializers[targetId]?.();

        if (persist) {
          const storedTarget = tab.dataset.target || targetId || tab.id;
          storeActiveSection(storedTarget);
        }
      };

      const focusTabAtIndex = (index) => {
        const tab = tabs[index];
        if (!tab) return;
        tab.focus();
        activateTab(tab, { persist: true });
      };

      const storedSectionTarget = getStoredActiveSection();
      const initialTab =
        (storedSectionTarget
          && tabs.find(tab =>
            tab.dataset.target === storedSectionTarget
            || tab.getAttribute("aria-controls") === storedSectionTarget
            || tab.id === storedSectionTarget
          ))
        || tabs.find(tab => tab.classList.contains("active"))
        || tabs[0];

      if (initialTab) {
        activateTab(initialTab, { persist: false });
      }

      tabs.forEach((tab, index) => {
        tab.addEventListener("click", () => {
          activateTab(tab, { focusPanel: true, persist: true });
          closeMainMenu();
        });

        tab.addEventListener("keydown", (event) => {
          const { key } = event;
          if (key === "ArrowRight" || key === "ArrowDown") {
            event.preventDefault();
            const nextIndex = (index + 1) % tabs.length;
            focusTabAtIndex(nextIndex);
          } else if (key === "ArrowLeft" || key === "ArrowUp") {
            event.preventDefault();
            const prevIndex = (index - 1 + tabs.length) % tabs.length;
            focusTabAtIndex(prevIndex);
          } else if (key === "Home") {
            event.preventDefault();
            focusTabAtIndex(0);
          } else if (key === "End") {
            event.preventDefault();
            focusTabAtIndex(tabs.length - 1);
          }
        });
      });

      const monsterQuery = document.getElementById("monster-query");
      const monsterCRSelect = document.getElementById("monster-cr-filter");
      const monsterTerrainSelect = document.getElementById("monster-terrain-filter");
      const monsterRoleSelect = document.getElementById("monster-role-filter");
      const bestiaryList = document.getElementById("bestiary-list");

      const encounterPartyLevelInput = document.getElementById("encounter-party-level");
      const encounterPartySizeInput = document.getElementById("encounter-party-size");
      const encounterSearchInput = document.getElementById("encounter-monster-query");
      const encounterResultsContainer = document.getElementById("encounter-monster-results");
      const encounterMinDiffInput = document.getElementById("encounter-min-diff");
      const encounterMaxDiffInput = document.getElementById("encounter-max-diff");
      const encounterRoleFiltersContainer = document.getElementById("encounter-role-filters");
      const encounterRosterList = document.getElementById("encounter-roster");
      const encounterSummaryContainer = document.getElementById("encounter-summary");
      const encounterClearButton = document.getElementById("encounter-clear");

      const initiativeForm = document.getElementById("initiative-form");
      const initiativeList = document.getElementById("initiative-list");
      const initiativeSortButton = document.getElementById("initiative-sort");
      const initiativeClearButton = document.getElementById("initiative-clear");
      const initiativeNextButton = document.getElementById("initiative-next");


      const raritySelect = document.getElementById("item-filter");
      const attunementSelect = document.getElementById("attunement-filter");
      const typeSelect = document.getElementById("item-type-filter");
      const editionSelect = document.getElementById("edition-filter");
      const contentTagSelect = document.getElementById("content-tag-filter");

      function ensureRarityOptions() {
        if (!raritySelect) return;
        const existingValues = new Set(Array.from(raritySelect.options).map(option => option.value));
        rarityOptions.forEach(rarity => {
          if (existingValues.has(rarity)) return;
          const option = document.createElement("option");
          option.value = rarity;
          option.textContent = rarity;
          raritySelect.appendChild(option);
        });
      }

      function buildItemFilters(items = []) {
        if (!typeSelect) return;
        const previousValue = typeSelect.value || "all";
        const typeSet = new Set(DEFAULT_ITEM_TYPES);
        items.forEach(item => {
          if (item && typeof item.type === "string") {
            typeSet.add(item.type);
          }
        });
        const sortedTypes = Array.from(typeSet).sort((a, b) => a.localeCompare(b));
        typeSelect.innerHTML = "";
        const allOption = document.createElement("option");
        allOption.value = "all";
        allOption.textContent = "All item types";
        typeSelect.appendChild(allOption);
        sortedTypes.forEach(type => {
          const option = document.createElement("option");
          option.value = type;
          option.textContent = type;
          typeSelect.appendChild(option);
        });
        if (previousValue !== "all" && sortedTypes.includes(previousValue)) {
          typeSelect.value = previousValue;
        } else {
          typeSelect.value = "all";
        }
      }

      ensureRarityOptions();
      buildItemFilters();

      const itemsList = document.getElementById("items-list");
      const itemQuery = document.getElementById("item-query");

      const downtimeForm = document.getElementById("downtime-form");
      const downtimeActivitySelect = document.getElementById("downtime-activity");
      const downtimeDynamicFields = document.getElementById("downtime-dynamic-fields");
      const downtimeSummary = document.getElementById("downtime-summary");
      const downtimeCopyBtn = document.getElementById("downtime-copy");

      const numberFormatter = new Intl.NumberFormat(undefined, { maximumFractionDigits: 2, minimumFractionDigits: 0 });

      const formatGp = (value) => {
        const safeValue = Number.isFinite(value) ? value : 0;
        const rounded = Math.round((safeValue + Number.EPSILON) * 100) / 100;
        const formatted = numberFormatter.format(rounded);
        return `${formatted} gp`;
      };

      const formatHours = (value) => {
        if (!Number.isFinite(value) || value <= 0) return "0 hours";
        const rounded = Math.round((value + Number.EPSILON) * 10) / 10;
        const digits = Number.isInteger(rounded) ? 0 : 1;
        const formatted = rounded.toLocaleString(undefined, { minimumFractionDigits: digits, maximumFractionDigits: digits });
        return `${formatted} hour${rounded === 1 ? "" : "s"}`;
      };

      const formatDays = (value) => {
        if (!Number.isFinite(value) || value <= 0) return "0 days";
        const rounded = Math.round((value + Number.EPSILON) * 10) / 10;
        const digits = Number.isInteger(rounded) ? 0 : 1;
        const formatted = rounded.toLocaleString(undefined, { minimumFractionDigits: digits, maximumFractionDigits: digits });
        return `${formatted} day${rounded === 1 ? "" : "s"}`;
      };

      const DOWNTIME_CONFIG = {
        crafting: {
          label: "Crafting (mundane item)",
          reference: "SRD 5.1, Downtime Activities – Crafting (Player's Handbook p. 187)",
          fields: [
            {
              id: "craft-market-price",
              name: "marketPrice",
              label: "Market price of the finished item (gp)",
              type: "number",
              min: 0,
              step: 1,
              value: 50,
              helper: "Enter the list cost of the item you want to produce.",
            },
            {
              id: "craft-days",
              name: "availableDays",
              label: "Downtime days you can invest now",
              type: "number",
              min: 1,
              step: 1,
              placeholder: "Optional",
              helper: "Track partial progress for a short crafting season.",
            },
          ],
          checkboxes: [
            {
              id: "craft-proficiency",
              name: "proficient",
              label: "Crafter is proficient with the required artisan's tools (advantage when appropriate)",
              defaultChecked: true,
            },
            {
              id: "craft-assistant",
              name: "assistant",
              label: "Working alongside at least one skilled helper (adds +5 gp progress/day)",
            },
            {
              id: "craft-guild",
              name: "guild",
              label: "Guild workshop or bulk materials discount (reduce costs by 25%)",
            },
          ],
          compute(values) {
            const marketPrice = Math.max(0, Number(values.marketPrice) || 0);
            if (!marketPrice) {
              return {
                headline: "Enter an item's market price to calculate a crafting plan.",
                timeText: "Awaiting input",
                costText: "Materials cost unknown",
                checkText: "Use the relevant artisan's tools with an ability check vs. a DC the DM sets for the item.",
                reference: this.reference,
                note: "Crafting requires access to tools and materials before work can begin.",
                copyText: "",
              };
            }

            const baseProgress = 5;
            const progressPerDay = baseProgress + (values.assistant ? 5 : 0);
            const totalDaysRaw = marketPrice / progressPerDay;
            const totalDays = Math.max(1, Math.ceil(totalDaysRaw));
            let materialsCost = marketPrice / 2;
            if (values.guild) {
              materialsCost *= 0.75;
            }

            const availableDays = Number.isFinite(values.availableDays) && values.availableDays > 0
              ? values.availableDays
              : null;
            const noteParts = [];

            if (availableDays) {
              const daysWorked = Math.min(availableDays, totalDaysRaw);
              const gpProgress = daysWorked * progressPerDay;
              const percentComplete = Math.min(gpProgress / marketPrice, 1) * 100;
              if (availableDays < totalDaysRaw) {
                const remainingDays = Math.ceil(totalDaysRaw - availableDays);
                noteParts.push(`With ${formatDays(availableDays)} scheduled you'll finish about ${Math.round(percentComplete)}% (${formatGp(gpProgress)}) and still need roughly ${formatDays(remainingDays)} later.`);
              } else {
                noteParts.push(`You can finish within the allotted ${formatDays(availableDays)} of downtime.`);
              }
            }

            if (values.assistant) {
              noteParts.push("A skilled assistant doubles your progress to 10 gp per day as long as they contribute their downtime.");
            }
            if (values.proficient) {
              noteParts.push("Tool proficiency supports advantage when the DM allows and avoids mishaps.");
            } else {
              noteParts.push("Without the right tool proficiency the DM may impose disadvantage or additional complications.");
            }

            const headline = `Crafting ${formatGp(marketPrice)} item`;
            const timeText = `${formatDays(totalDays)} of downtime at ${progressPerDay} gp progress per day.`;
            const costText = `${formatGp(materialsCost)} in materials${values.guild ? " after the guild discount." : "."}`;
            const checkText = `Ability check with the relevant artisan's tools vs. a DC the DM sets for the item's complexity${values.proficient ? "; you qualify for proficiency bonuses" : "."}`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Crafting`,
              `Item market price: ${formatGp(marketPrice)}`,
              `Daily progress: ${progressPerDay} gp`,
              `Downtime required: ${formatDays(totalDays)}`,
              availableDays ? `Scheduled now: ${formatDays(availableDays)}` : null,
              `Materials needed: ${formatGp(materialsCost)}${values.guild ? " (25% guild discount)" : ""}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        scribing: {
          label: "Scribing a spell",
          reference: "SRD 5.1, Wizard Spellbook – Copying a Spell (Player's Handbook p. 114)",
          fields: [
            {
              id: "scribe-level",
              name: "spellLevel",
              label: "Spell level",
              type: "select",
              options: [
                { value: "0", label: "Cantrip" },
                { value: "1", label: "1st level" },
                { value: "2", label: "2nd level" },
                { value: "3", label: "3rd level" },
                { value: "4", label: "4th level" },
                { value: "5", label: "5th level" },
                { value: "6", label: "6th level" },
                { value: "7", label: "7th level" },
                { value: "8", label: "8th level" },
                { value: "9", label: "9th level" },
              ],
              value: "1",
            },
            {
              id: "scribe-count",
              name: "copies",
              label: "Number of spells",
              type: "number",
              min: 1,
              step: 1,
              value: 1,
            },
          ],
          checkboxes: [
            {
              id: "scribe-tradition",
              name: "traditionDiscount",
              label: "Arcane tradition (e.g., School Savant) halves the gold and time",
            },
            {
              id: "scribe-owned-source",
              name: "ownSource",
              label: "Copying from your own scroll or notes (time halved, gold unchanged)",
            },
          ],
          compute(values) {
            const level = Number(values.spellLevel ?? 0);
            const copies = Math.max(0, Number(values.copies) || 0);

            if (!copies) {
              return {
                headline: "Enter how many spells you're transcribing to see costs.",
                timeText: "Awaiting input",
                costText: "Inks and rare parchment cost unknown",
                checkText: "No check is normally required; you spend the time and gold automatically.",
                reference: this.reference,
                note: "Scribing demands the spell must already be prepared or available to copy.",
                copyText: "",
              };
            }

            const baseLevelCost = level <= 0 ? 0 : level * 50;
            const baseLevelHours = level <= 0 ? 0 : level * 2;
            let totalCost = baseLevelCost * copies;
            let totalHours = baseLevelHours * copies;

            if (values.traditionDiscount) {
              totalCost *= 0.5;
              totalHours *= 0.5;
            }
            if (values.ownSource) {
              totalHours *= 0.5;
            }

            const downtimeDays = totalHours / 8;
            const timeText = totalHours > 0
              ? `${formatHours(totalHours)} of focused writing (~${formatDays(Math.max(1, Math.ceil(downtimeDays || 0)))})`
              : "No downtime needed; cantrips don't require copying in the SRD.";
            const costText = totalCost > 0
              ? `${formatGp(totalCost)} in inks and fine parchment.`
              : "No gold cost for cantrips.";
            const checkText = "No check required; failure only occurs if you lack time or the spell is higher level than you can prepare.";

            const noteParts = [];
            if (values.traditionDiscount) {
              noteParts.push("Tradition features halve both cost and time.");
            }
            if (values.ownSource) {
              noteParts.push("Copying from your own notes halves the remaining time requirement.");
            }
            if (level === 0) {
              noteParts.push("Cantrips are usually gained through leveling, so copying rules may not apply—confirm with your DM.");
            }

            const headline = copies === 1
              ? `Scribing a ${level === 0 ? "cantrip" : `${level}th-level`} spell`
              : `Scribing ${copies} spells of level ${level}`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Scribing spells`,
              `Spell level: ${level}`,
              `Number of spells: ${copies}`,
              `Time required: ${timeText}`,
              `Cost: ${costText}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        training: {
          label: "Training proficiency",
          reference: "SRD 5.1, Downtime Activities – Training (Player's Handbook p. 187)",
          fields: [
            {
              id: "training-focus",
              name: "focus",
              label: "Training goal",
              type: "select",
              options: [
                { value: "tool", label: "Tool proficiency" },
                { value: "language", label: "New language" },
              ],
              value: "tool",
            },
            {
              id: "training-days",
              name: "availableDays",
              label: "Downtime days you can commit now",
              type: "number",
              min: 1,
              step: 1,
              placeholder: "Optional",
              helper: "Track how long the current training block lasts.",
            },
          ],
          checkboxes: [
            {
              id: "training-mentor",
              name: "mentor",
              label: "Dedicated tutor speeds training (time halved, gold doubled per day)",
            },
            {
              id: "training-related",
              name: "related",
              label: "Already proficient in a closely related skill (time reduced by 25%)",
            },
          ],
          compute(values) {
            const baseDays = 250;
            let totalDays = baseDays;
            let dailyCost = 1;

            if (values.mentor) {
              totalDays *= 0.5;
              dailyCost = 2;
            }
            if (values.related) {
              totalDays *= 0.75;
            }

            totalDays = Math.max(1, Math.ceil(totalDays));
            const totalCost = totalDays * dailyCost;

            const availableDays = Number.isFinite(values.availableDays) && values.availableDays > 0
              ? values.availableDays
              : null;

            const noteParts = [];
            if (values.mentor) {
              noteParts.push("A tutor accelerates progress but charges 2 gp per day.");
            }
            if (values.related) {
              noteParts.push("Related experience trims 25% off the schedule.");
            }
            if (availableDays) {
              if (availableDays < totalDays) {
                const remaining = Math.max(0, totalDays - availableDays);
                noteParts.push(`After ${formatDays(availableDays)} you'll need about ${formatDays(remaining)} more to finish.`);
              } else {
                noteParts.push(`You can complete the training within ${formatDays(availableDays)}.`);
              }
            }

            const focusText = values.focus === "language" ? "a new language" : "a tool proficiency";
            const headline = `Training ${focusText}`;
            const timeText = `${formatDays(totalDays)} of instruction at ${dailyCost} gp per day.`;
            const costText = `${formatGp(totalCost)} total tuition.`;
            const checkText = "No roll required; completion grants the proficiency after you invest the downtime and gold.";
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Training`,
              `Goal: ${focusText}`,
              `Downtime required: ${formatDays(totalDays)}`,
              availableDays ? `Scheduled now: ${formatDays(availableDays)}` : null,
              `Daily cost: ${formatGp(dailyCost)}`,
              `Total cost: ${formatGp(totalCost)}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        carousing: {
          label: "Carousing (social downtime)",
          reference: "Dungeon Master's Guide (5e) p. 128 – Carousing",
          fields: [
            {
              id: "carousing-days",
              name: "days",
              label: "Downtime days invested",
              type: "number",
              min: 1,
              step: 1,
              value: 7,
              helper: "Seven days equals one workweek in the DMG example.",
            },
            {
              id: "carousing-lifestyle",
              name: "lifestyle",
              label: "Lifestyle bracket",
              type: "select",
              options: [
                { value: "lower", label: "Lower class (10 gp/day)" },
                { value: "middle", label: "Middle class (50 gp/day)" },
                { value: "upper", label: "Upper class (250 gp/day)" },
              ],
              value: "lower",
            },
          ],
          checkboxes: [
            {
              id: "carousing-contacts",
              name: "contacts",
              label: "Existing allies grease the wheels (reduce DC by 2)",
            },
            {
              id: "carousing-bribes",
              name: "bribes",
              label: "Spend 50 gp on extra bribes for advantage on the final check",
            },
          ],
          compute(values) {
            const lifestyles = {
              lower: { label: "lower class", dailyCost: 10, dc: 10 },
              middle: { label: "middle class", dailyCost: 50, dc: 15 },
              upper: { label: "upper class", dailyCost: 250, dc: 20 },
            };
            const selected = lifestyles[values.lifestyle] ?? lifestyles.lower;
            const days = Math.max(1, Number(values.days) || 0);
            const baseCost = selected.dailyCost * days;
            const bribeCost = values.bribes ? 50 : 0;
            const totalCost = baseCost + bribeCost;

            let dc = selected.dc;
            const noteParts = [];
            if (values.contacts) {
              dc = Math.max(5, dc - 2);
              noteParts.push("Trusted allies vouch for you, reducing complications.");
            }
            if (values.bribes) {
              noteParts.push("Extra bribes grant advantage on the Charisma (Persuasion) check in addition to the 50 gp surcharge.");
            }
            noteParts.push("On success you gain 1d4 new contacts or favors; failure invites a complication (DMG p. 128).");

            const headline = `Carousing among the ${selected.label}`;
            const timeText = `${formatDays(days)} of revelry and networking.`;
            const costText = `${formatGp(totalCost)} in lifestyle expenses${values.bribes ? ", including bribes." : "."}`;
            const checkText = `Charisma (Persuasion) vs. DC ${dc} at the end of each workweek${values.bribes ? " with advantage." : "."}`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Carousing (${selected.label})`,
              `Downtime invested: ${formatDays(days)}`,
              `Lifestyle cost: ${formatGp(baseCost)}`,
              values.bribes ? `Bribe surcharge: ${formatGp(bribeCost)}` : null,
              `Total cost: ${formatGp(totalCost)}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        research: {
          label: "Research a lore topic",
          reference: "Dungeon Master's Guide (5e) p. 129 – Research",
          fields: [
            {
              id: "research-days",
              name: "days",
              label: "Downtime days spent researching",
              type: "number",
              min: 1,
              step: 1,
              value: 5,
              helper: "Five days equals one workweek of focused study.",
            },
            {
              id: "research-difficulty",
              name: "difficulty",
              label: "Lore difficulty",
              type: "select",
              options: [
                { value: "common", label: "Common lore (DC 10, 1 workweek)" },
                { value: "hidden", label: "Hidden or obscure (DC 15, 2 workweeks)" },
                { value: "esoteric", label: "Esoteric secrets (DC 20, 3 workweeks)" },
              ],
              value: "common",
            },
            {
              id: "research-investment",
              name: "investment",
              label: "Extra gold for gifts or bribes (gp)",
              type: "number",
              min: 0,
              step: 1,
              value: 0,
              helper: "Represents special donations or rare books offered to archives.",
            },
          ],
          checkboxes: [
            {
              id: "research-library",
              name: "library",
              label: "Legendary archive access grants advantage on the final check",
            },
            {
              id: "research-sage",
              name: "sage",
              label: "Hire a sage for 100 gp (reduces DC by 2)",
            },
          ],
          compute(values) {
            const tiers = {
              common: { label: "common lore", dc: 10, recommendedWeeks: 1 },
              hidden: { label: "hidden lore", dc: 15, recommendedWeeks: 2 },
              esoteric: { label: "esoteric secrets", dc: 20, recommendedWeeks: 3 },
            };
            const selected = tiers[values.difficulty] ?? tiers.common;
            const days = Math.max(1, Number(values.days) || 0);
            const workweeks = Math.max(1, Math.ceil(days / 5));
            const baseCost = workweeks * 50;
            const extraInvestment = Math.max(0, Number(values.investment) || 0);
            let totalCost = baseCost + extraInvestment;

            let dc = selected.dc;
            const noteParts = [];
            if (values.sage) {
              dc = Math.max(5, dc - 2);
              totalCost += 100;
              noteParts.push("A sage's guidance costs 100 gp but reduces the target DC by 2.");
            }
            if (values.library) {
              noteParts.push("Prestigious archives typically grant advantage on the Intelligence check.");
            }
            noteParts.push("Each successful check yields a lore discovery; three successes uncover deep secrets per DMG guidance.");

            const advantageText = values.library ? " with advantage" : "";
            const headline = `Researching ${selected.label}`;
            const timeText = `${formatDays(days)} of study (~${workweeks} workweek${workweeks === 1 ? "" : "s"}).`;
            const costText = `${formatGp(totalCost)} in donations, materials, and expert fees.`;
            const checkText = `Intelligence (Arcana, History, or Investigation) vs. DC ${dc}${advantageText}.`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Research (${selected.label})`,
              `Downtime invested: ${formatDays(days)} (${workweeks} workweek${workweeks === 1 ? "" : "s"})`,
              `Base cost: ${formatGp(baseCost)}`,
              extraInvestment ? `Additional gifts: ${formatGp(extraInvestment)}` : null,
              values.sage ? `Sage retainer: ${formatGp(100)}` : null,
              `Total cost: ${formatGp(totalCost)}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        business: {
          label: "Running a business",
          reference: "Dungeon Master's Guide (5e) p. 127 – Running a Business",
          fields: [
            {
              id: "business-days",
              name: "days",
              label: "Downtime days running the business",
              type: "number",
              min: 1,
              step: 1,
              value: 7,
              helper: "A workweek is seven days in the DMG example.",
            },
            {
              id: "business-maintenance",
              name: "maintenance",
              label: "Daily maintenance expense (gp)",
              type: "number",
              min: 0,
              step: 1,
              value: 5,
              helper: "Use the establishment's upkeep cost or lifestyle expense.",
            },
            {
              id: "business-roll",
              name: "roll",
              label: "d100 roll (before modifiers)",
              type: "number",
              min: 1,
              max: 100,
              step: 1,
              helper: "Enter the raw d100 before adding downtime or bonuses.",
            },
          ],
          checkboxes: [
            {
              id: "business-promotions",
              name: "promotions",
              label: "Spend 25 gp on promotions (+10 to the roll)",
            },
            {
              id: "business-renown",
              name: "renown",
              label: "Renown, skilled staff, or magic aids grant +10 to the roll",
            },
          ],
          compute(values) {
            const days = Math.max(1, Number(values.days) || 0);
            const maintenancePerDay = Math.max(0, Number(values.maintenance) || 0);
            const baseUpkeep = maintenancePerDay * days;
            const baseRoll = Number(values.roll) || 0;

            if (!baseRoll) {
              return {
                headline: "Enter your d100 result to resolve profits.",
                timeText: "Awaiting roll",
                costText: `${formatGp(baseUpkeep)} in upkeep so far`,
                checkText: "Roll d100 + downtime days (max 30) + modifiers; compare to DMG Running a Business table.",
                reference: this.reference,
                note: "Include promotions or renown bonuses to adjust the final total.",
                copyText: "",
              };
            }

            let totalCost = baseUpkeep;
            let modifiers = Math.min(days, 30);
            const noteParts = [];

            if (values.promotions) {
              totalCost += 25;
              modifiers += 10;
              noteParts.push("Promotions add 25 gp in expenses and +10 to the d100 total.");
            }
            if (values.renown) {
              modifiers += 10;
              noteParts.push("Renown, skilled staff, or magical assistance provide +10 to the d100 total.");
            }

            const finalTotal = baseRoll + modifiers;

            let outcome;
            let averageNet = 0;
            if (finalTotal <= 20) {
              outcome = "Pay 1d6 × 5 gp";
              averageNet = -17.5;
            } else if (finalTotal <= 30) {
              outcome = "Pay 1d6 × 2 gp";
              averageNet = -7;
            } else if (finalTotal <= 40) {
              outcome = "Pay 1d6 gp";
              averageNet = -3.5;
            } else if (finalTotal <= 60) {
              outcome = "Break even";
              averageNet = 0;
            } else if (finalTotal <= 80) {
              outcome = "Earn 1d6 × 2 gp";
              averageNet = 7;
            } else if (finalTotal <= 90) {
              outcome = "Earn 1d6 × 5 gp";
              averageNet = 17.5;
            } else {
              outcome = "Earn 2d8 × 5 gp";
              averageNet = 45;
            }

            if (averageNet !== 0) {
              noteParts.push(`Average outcome from the roll (using mean dice) ≈ ${formatGp(averageNet)} before subtracting upkeep and promotions.`);
            }
            noteParts.push("Apply the outcome after subtracting the upkeep you've already paid.");

            const headline = `Running the business for ${formatDays(days)}`;
            const timeText = `${formatDays(days)} tending to the enterprise.`;
            const costText = `${formatGp(totalCost)} in upkeep${values.promotions ? " including promotions." : "."}`;
            const checkText = `Final roll: ${finalTotal} (${baseRoll} base + ${modifiers} modifiers). Compare to the Running a Business table.`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Running a business`,
              `Downtime invested: ${formatDays(days)}`,
              `Base upkeep: ${formatGp(baseUpkeep)}`,
              values.promotions ? `Promotions: ${formatGp(25)}` : null,
              `Total upkeep: ${formatGp(totalCost)}`,
              `Final roll total: ${finalTotal}`,
              `Outcome guidance: ${outcome}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
        bastion: {
          label: "Bastion turn (2024)",
          reference: "Dungeon Master's Guide (2024 preview) – Bastion Turns",
          fields: [
            {
              id: "bastion-weeks",
              name: "weeks",
              label: "Number of bastion turns",
              type: "number",
              min: 1,
              step: 1,
              value: 1,
              helper: "Each bastion turn equals one week of downtime.",
            },
            {
              id: "bastion-level",
              name: "level",
              label: "Bastion level",
              type: "number",
              min: 1,
              step: 1,
              value: 5,
              helper: "Use your bastion level from the 2024 DMG preview.",
            },
            {
              id: "bastion-focus",
              name: "focus",
              label: "Primary focus this turn",
              type: "select",
              options: [
                { value: "project", label: "Project advancement" },
                { value: "facility", label: "Facility production" },
                { value: "recruit", label: "Recruitment & training" },
                { value: "defend", label: "Defense readiness" },
              ],
              value: "project",
            },
            {
              id: "bastion-investment",
              name: "investment",
              label: "Additional gp invested this turn",
              type: "number",
              min: 0,
              step: 1,
              value: 0,
              helper: "Covers optional upgrades or rush orders.",
            },
          ],
          checkboxes: [
            {
              id: "bastion-warden",
              name: "warden",
              label: "Dedicated bastion warden adds +5 to checks and +1 reward step",
            },
            {
              id: "bastion-threat",
              name: "threat",
              label: "Bastion threatened this turn (DC 15 bastion check)",
            },
          ],
          compute(values) {
            const weeks = Math.max(1, Number(values.weeks) || 0);
            const level = Math.max(1, Number(values.level) || 0);
            const investment = Math.max(0, Number(values.investment) || 0);
            const focusKey = values.focus || "project";

            const focusMap = {
              project: {
                label: "Project advancement",
                reward: `${level * weeks * 2} project points`,
                detail: "Spend points to unlock upgrades or accelerate facilities.",
              },
              facility: {
                label: "Facility production",
                reward: `${formatGp(level * weeks * 50)} of goods or services`,
                detail: "Convert to gp, reagents, or benefits based on active facilities.",
              },
              recruit: {
                label: "Recruitment & training",
                reward: `${level * weeks} trained retainers`,
                detail: "Assign them to facility tasks or bastion missions.",
              },
              defend: {
                label: "Defense readiness",
                reward: `${level * weeks} security successes`,
                detail: "Each success cancels one threat complication during bastion resolution.",
              },
            };

            const focus = focusMap[focusKey] ?? focusMap.project;
            const upkeep = level * 25 * weeks;
            const totalCost = upkeep + investment;

            const dc = values.threat ? 15 : 10;
            const noteParts = [
              `Base upkeep: ${formatGp(upkeep)} (${level * 25} gp per week × ${weeks} week${weeks === 1 ? "" : "s"}).`,
            ];
            if (values.warden) {
              noteParts.push("Active warden grants +5 to the bastion check and improves rewards by one step.");
            }
            if (values.threat) {
              noteParts.push("A threatened bastion requires a DC 15 check; failure may trigger incursions.");
            }
            noteParts.push(focus.detail);

            const checkBonus = values.warden ? "+5 warden bonus" : "no bonus";
            const headline = `${focus.label} bastion turn`;
            const timeText = `${weeks} bastion turn${weeks === 1 ? "" : "s"} (~${formatDays(weeks * 7)}) resolved.`;
            const costText = `${formatGp(totalCost)} in upkeep and investments.`;
            const checkText = `Bastion ability check vs. DC ${dc} (${checkBonus}).`;
            const reference = this.reference;
            const note = noteParts.join(" ");

            const copyLines = [
              `Downtime activity: Bastion turn (${focus.label})`,
              `Turns resolved: ${weeks} (${formatDays(weeks * 7)})`,
              `Bastion level: ${level}`,
              `Base upkeep: ${formatGp(upkeep)}`,
              investment ? `Additional investment: ${formatGp(investment)}` : null,
              `Total cost: ${formatGp(totalCost)}`,
              `Projected reward: ${focus.reward}${values.warden ? " (+1 step from warden)" : ""}`,
              `Check guidance: ${checkText}`,
              note ? `Notes: ${note}` : null,
              `Reference: ${reference}`,
            ].filter(Boolean).join("\n");

            return { headline, timeText, costText, checkText, reference, note, copyText: copyLines };
          },
        },
      };

      const buildFieldControl = (field) => {
        const wrapper = document.createElement("label");
        wrapper.htmlFor = field.id;
        wrapper.appendChild(document.createTextNode(field.label));

        let control;
        if (field.type === "select") {
          control = document.createElement("select");
          control.id = field.id;
          control.name = field.name;
          field.options.forEach(opt => {
            const option = document.createElement("option");
            option.value = opt.value;
            option.textContent = opt.label;
            control.appendChild(option);
          });
          if (field.value !== undefined) {
            control.value = field.value;
          }
        } else {
          control = document.createElement("input");
          control.type = field.type || "text";
          control.id = field.id;
          control.name = field.name;
          if (field.placeholder) control.placeholder = field.placeholder;
          if (field.min !== undefined) control.min = field.min;
          if (field.max !== undefined) control.max = field.max;
          if (field.step !== undefined) control.step = field.step;
          if (field.value !== undefined && field.value !== null) control.value = field.value;
        }

        wrapper.appendChild(control);

        if (field.helper) {
          const helper = document.createElement("span");
          helper.style.fontSize = "0.75rem";
          helper.style.opacity = "0.7";
          helper.textContent = field.helper;
          wrapper.appendChild(helper);
        }

        return wrapper;
      };

      const buildCheckboxControl = (checkbox) => {
        const wrapper = document.createElement("label");
        wrapper.htmlFor = checkbox.id;
        const control = document.createElement("input");
        control.type = "checkbox";
        control.id = checkbox.id;
        control.name = checkbox.name;
        control.checked = Boolean(checkbox.defaultChecked);
        wrapper.appendChild(control);
        const text = document.createElement("span");
        text.textContent = checkbox.label;
        wrapper.appendChild(text);
        return wrapper;
      };

      const renderDowntimeFields = (activityKey) => {
        const config = DOWNTIME_CONFIG[activityKey];
        downtimeDynamicFields.innerHTML = "";
        if (!config) return;

        config.fields?.forEach(field => {
          const fieldControl = buildFieldControl(field);
          downtimeDynamicFields.appendChild(fieldControl);
        });

        if (config.checkboxes?.length) {
          const checkboxGroup = document.createElement("div");
          checkboxGroup.className = "downtime-checkboxes";
          config.checkboxes.forEach(box => {
            const checkboxControl = buildCheckboxControl(box);
            checkboxGroup.appendChild(checkboxControl);
          });
          downtimeDynamicFields.appendChild(checkboxGroup);
        }
      };

      const collectDowntimeValues = (activityKey) => {
        const config = DOWNTIME_CONFIG[activityKey];
        const values = {};
        if (!config) return values;
        config.fields?.forEach(field => {
          const control = downtimeForm.querySelector(`[name="${field.name}"]`);
          if (!control) return;
          if (field.type === "number") {
            const raw = control.value.trim();
            values[field.name] = raw === "" ? null : Number(raw);
          } else {
            values[field.name] = control.value;
          }
        });
        config.checkboxes?.forEach(box => {
          const control = downtimeForm.querySelector(`[name="${box.name}"]`);
          if (!control) return;
          values[box.name] = control.checked;
        });
        return values;
      };

      const updateDowntimeSummary = () => {
        const activityKey = downtimeActivitySelect.value;
        const config = DOWNTIME_CONFIG[activityKey];
        if (!config) return;
        const values = collectDowntimeValues(activityKey);
        const result = config.compute(values);

        downtimeSummary.innerHTML = `
          <strong>${result.headline}</strong>
          <dl>
            <dt>Time required</dt>
            <dd>${result.timeText}</dd>
            <dt>Gold cost</dt>
            <dd>${result.costText}</dd>
            <dt>Checks</dt>
            <dd>${result.checkText}</dd>
            <dt>Reference</dt>
            <dd>${result.reference}</dd>
          </dl>
          ${result.note ? `<p style="margin: 0; font-size: 0.8rem; opacity: 0.75;">${result.note}</p>` : ""}
        `;

        const copyText = result.copyText ?? "";
        if (copyText) {
          downtimeCopyBtn.disabled = false;
          downtimeCopyBtn.dataset.summary = copyText;
          downtimeCopyBtn.textContent = "Copy summary";
        } else {
          downtimeCopyBtn.disabled = true;
          downtimeCopyBtn.dataset.summary = "";
        }
      };

      downtimeActivitySelect.addEventListener("change", () => {
        renderDowntimeFields(downtimeActivitySelect.value);
        updateDowntimeSummary();
      });

      downtimeForm.addEventListener("input", () => {
        updateDowntimeSummary();
      });

      downtimeForm.addEventListener("change", () => {
        updateDowntimeSummary();
      });

      downtimeCopyBtn.addEventListener("click", async () => {
        const summary = downtimeCopyBtn.dataset.summary;
        if (!summary) return;
        let copied = false;
        if (navigator.clipboard?.writeText) {
          try {
            await navigator.clipboard.writeText(summary);
            copied = true;
          } catch (err) {
            console.warn("Clipboard API failed, falling back", err);
          }
        }
        if (!copied) {
          const temp = document.createElement("textarea");
          temp.value = summary;
          temp.setAttribute("readonly", "readonly");
          temp.style.position = "absolute";
          temp.style.left = "-9999px";
          document.body.appendChild(temp);
          temp.select();
          try {
            document.execCommand("copy");
            copied = true;
          } catch (err) {
            console.error("Fallback copy failed", err);
          }
          document.body.removeChild(temp);
        }
        if (copied) {
          const originalText = downtimeCopyBtn.textContent;
          downtimeCopyBtn.textContent = "Copied!";
          downtimeCopyBtn.disabled = true;
          setTimeout(() => {
            downtimeCopyBtn.textContent = originalText;
            downtimeCopyBtn.disabled = false;
          }, 2000);
        }
      });

      renderDowntimeFields(downtimeActivitySelect.value);
      updateDowntimeSummary();

      
      // WebLLM setup
      const logEl = document.getElementById("chat-log");
      const promptEl = document.getElementById("prompt");
      const sendBtn = document.getElementById("send");
      const statusEl = document.getElementById("status");
      const statusMetaEl = document.getElementById("status-meta");
      const modelSelect = document.getElementById("model-select");
      const temperatureSlider = document.getElementById("temperature-slider");
      const maxTokensSlider = document.getElementById("max-tokens-slider");
      const temperatureDisplay = document.getElementById("temperature-display");
      const maxTokensDisplay = document.getElementById("max-tokens-display");
      const promptToastEl = document.getElementById("prompt-toast");
      const isMobileDevice = typeof navigator !== "undefined"
        && /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent ?? "");

      let availableModels = [];
      let promptToastTimeout;
      const autoSendQuickPrompts = true;
      let webllmModule;
      let webllmLoadPromise;
      let activeModelId = null;
      let loadingModelId = null;
      let queuedModelId = null;
      let pendingModelReload = null;
      let currentInitStage = "";

      const defaultGenerationSettings = {
        temperature: 0.5,
        maxTokens: isMobileDevice ? 256 : 400
      };
      const storedGenerationSettings = readJSONFromStorage(STORAGE_KEYS.generation, null);
      let generationSettings = { ...defaultGenerationSettings };

      if (storedGenerationSettings && typeof storedGenerationSettings === "object") {
        if (Number.isFinite(storedGenerationSettings.temperature)) {
          generationSettings.temperature = clampNumber(Number(storedGenerationSettings.temperature), 0, 2);
        }
        if (Number.isFinite(storedGenerationSettings.maxTokens)) {
          generationSettings.maxTokens = clampNumber(Number(storedGenerationSettings.maxTokens), 16, 4096);
        }
      }

      const persistGenerationSettings = () => {
        writeJSONToStorage(STORAGE_KEYS.generation, generationSettings);
      };

      const setTemperature = (value, { persist = true } = {}) => {
        const sliderMin = Number(temperatureSlider?.min ?? 0);
        const sliderMax = Number(temperatureSlider?.max ?? 1);
        const sanitized = clampNumber(Number(value), sliderMin, sliderMax);
        const rounded = Math.round(sanitized * 100) / 100;
        generationSettings.temperature = rounded;
        if (temperatureSlider && Number(temperatureSlider.value) !== rounded) {
          temperatureSlider.value = rounded.toString();
        }
        if (temperatureDisplay) {
          temperatureDisplay.textContent = rounded.toFixed(2);
        }
        if (persist) {
          persistGenerationSettings();
        }
      };

      const setMaxTokens = (value, { persist = true } = {}) => {
        const sliderMin = Number(maxTokensSlider?.min ?? 1);
        const sliderMax = Number(maxTokensSlider?.max ?? (isMobileDevice ? 512 : 1024));
        const step = Number(maxTokensSlider?.step ?? 1);
        const clamped = clampNumber(Number(value), sliderMin, sliderMax);
        const stepped = Math.round(clamped / step) * step;
        const sanitized = Math.max(step, Math.round(stepped));
        generationSettings.maxTokens = sanitized;
        if (maxTokensSlider && Number(maxTokensSlider.value) !== sanitized) {
          maxTokensSlider.value = sanitized.toString();
        }
        if (maxTokensDisplay) {
          maxTokensDisplay.textContent = sanitized.toString();
        }
        if (persist) {
          persistGenerationSettings();
        }
      };

      const getGenerationOptions = () => {
        const tempMin = Number(temperatureSlider?.min ?? 0);
        const tempMax = Number(temperatureSlider?.max ?? 1);
        const tokenMin = Number(maxTokensSlider?.min ?? 16);
        const tokenMax = Number(maxTokensSlider?.max ?? (isMobileDevice ? 512 : 2048));
        const temperature = clampNumber(
          Number(generationSettings.temperature ?? defaultGenerationSettings.temperature),
          tempMin,
          tempMax
        );
        const maxTokens = clampNumber(
          Number(generationSettings.maxTokens ?? defaultGenerationSettings.maxTokens),
          tokenMin,
          tokenMax
        );
        return {
          temperature: Math.round(temperature * 100) / 100,
          max_tokens: Math.max(16, Math.round(maxTokens))
        };
      };

      setTemperature(generationSettings.temperature, { persist: false });
      setMaxTokens(generationSettings.maxTokens, { persist: false });

      const showPromptToast = (message) => {
        if (!promptToastEl) return;
        clearTimeout(promptToastTimeout);
        if (!message) {
          promptToastEl.hidden = true;
          promptToastEl.textContent = "";
          return;
        }
        promptToastEl.hidden = false;
        promptToastEl.style.opacity = "1";
        promptToastEl.textContent = message;
        promptToastTimeout = setTimeout(() => {
          if (!promptToastEl) return;
          promptToastEl.style.opacity = "0";
          promptToastTimeout = setTimeout(() => {
            if (!promptToastEl) return;
            promptToastEl.hidden = true;
            promptToastEl.style.opacity = "";
          }, 200);
        }, 2200);
      };

      const ensureWebLLMModule = async () => {
        if (webllmModule) {
          return webllmModule;
        }
        if (!webllmLoadPromise) {
          webllmLoadPromise = import("https://esm.run/@mlc-ai/web-llm")
            .then(mod => {
              webllmModule = mod;
              return mod;
            })
            .catch(error => {
              webllmLoadPromise = null;
              throw error;
            });
        }
        return webllmLoadPromise;
      };

      const disposeEngine = async () => {
        if (!engine) return;
        const disposalMethods = ["unload", "dispose", "destroy", "reset"];
        const tasks = disposalMethods
          .map(method => {
            const fn = engine?.[method];
            if (typeof fn === "function") {
              try {
                return Promise.resolve(fn.call(engine));
              } catch (error) {
                console.warn(`Engine ${method} failed synchronously`, error);
              }
            }
            return null;
          })
          .filter(Boolean);
        if (tasks.length) {
          await Promise.allSettled(tasks);
        }
        engine = null;
      };

      temperatureSlider?.addEventListener("input", () => {
        setTemperature(temperatureSlider.value);
      });

      maxTokensSlider?.addEventListener("input", () => {
        setMaxTokens(maxTokensSlider.value);
      });

      const setStatusMeta = (text) => {
        if (!statusMetaEl) return;
        if (text) {
          statusMetaEl.hidden = false;
          statusMetaEl.textContent = text;
        } else {
          statusMetaEl.hidden = true;
          statusMetaEl.textContent = "";
        }
      };

      const formatBytesReadable = (bytes) => {
        if (!Number.isFinite(bytes) || bytes <= 0) return null;
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
          value /= 1024;
          unitIndex += 1;
        }
        const precision = value >= 10 || unitIndex === 0 ? 0 : 1;
        return `${value.toFixed(precision)} ${units[unitIndex]}`;
      };

      const formatStageLabel = (text = "") => {
        const clean = `${text}`.replace(/\.+$/, "").trim();
        if (!clean) return "";
        const tokens = clean.split(/\s+/);
        if (tokens.length <= 2) {
          return clean;
        }
        return `${tokens[0]} ${tokens[1]}`;
      };

      const getModelSizeBytes = (model) => {
        const candidates = [
          model?.estimated_vram_bytes,
          model?.model_size_in_bytes,
          model?.estimated_total_weight_size,
          model?.estimated_total_weight_size_bytes,
          model?.size_in_bytes,
          model?.file_size_bytes
        ];
        for (const candidate of candidates) {
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            return value;
          }
        }
        if (Number.isFinite(model?.estimated_vram_gb)) {
          return Number(model.estimated_vram_gb) * 1024 ** 3;
        }
        if (Number.isFinite(model?.estimated_vram_mb)) {
          return Number(model.estimated_vram_mb) * 1024 ** 2;
        }
        return null;
      };

      const getModelContextTokens = (model) => {
        const candidates = [
          model?.context_window_size,
          model?.context_length,
          model?.max_window_size,
          model?.prefill_context,
          model?.max_total_tokens,
          model?.max_tokens
        ];
        for (const candidate of candidates) {
          const value = Number(candidate);
          if (Number.isFinite(value) && value > 0) {
            return Math.round(value);
          }
        }
        return null;
      };

      const getDeviceMemoryBytes = () => {
        if (typeof navigator === "undefined") return null;
        const memory = Number(navigator?.deviceMemory);
        if (Number.isFinite(memory) && memory > 0) {
          return memory * 1024 ** 3;
        }
        return null;
      };

      const getDeviceMemoryBudgetBytes = () => {
        const memoryBytes = getDeviceMemoryBytes();
        const fallbackBudget = isMobileDevice ? 512 * 1024 ** 2 : null;
        if (!Number.isFinite(memoryBytes) || memoryBytes <= 0) {
          return fallbackBudget;
        }
        const multiplier = isMobileDevice ? 0.35 : 0.6;
        const minimum = (isMobileDevice ? 384 : 512) * 1024 ** 2;
        const cap = isMobileDevice ? 1024 ** 3 : Number.POSITIVE_INFINITY;
        const budget = memoryBytes * multiplier;
        const clamped = Math.max(budget, minimum);
        return Math.min(clamped, cap);
      };

      const getModelSizeScore = (model) => {
        const size = getModelSizeBytes(model);
        if (Number.isFinite(size) && size > 0) {
          return size;
        }
        return Number.POSITIVE_INFINITY;
      };

      const compareModelsBySize = (a, b) => {
        const diff = getModelSizeScore(a) - getModelSizeScore(b);
        if (Number.isFinite(diff) && diff !== 0) {
          return diff;
        }
        const aName = getModelDisplayName(a);
        const bName = getModelDisplayName(b);
        return aName.localeCompare(bName);
      };

      const getSortedModelsBySize = (models = availableModels) => {
        if (!Array.isArray(models)) return [];
        return [...models].sort(compareModelsBySize);
      };

      const filterModelsByMemoryBudget = (models = availableModels) => {
        const budget = getDeviceMemoryBudgetBytes();
        if (!Array.isArray(models) || !budget) {
          return models ?? [];
        }
        const filtered = models.filter(model => {
          const size = getModelSizeBytes(model);
          if (!Number.isFinite(size) || size <= 0) {
            return true;
          }
          return size <= budget;
        });
        return filtered.length ? filtered : models;
      };

      const isModelLikelyTooLargeForDevice = (model) => {
        const budget = getDeviceMemoryBudgetBytes();
        if (!budget) return false;
        const size = getModelSizeBytes(model);
        if (!Number.isFinite(size) || size <= 0) return false;
        return size > budget;
      };

      const describeModelSizeRisk = (model) => {
        if (!isModelLikelyTooLargeForDevice(model)) return null;
        const sizeBytes = getModelSizeBytes(model);
        const deviceBytes = getDeviceMemoryBytes();
        if (!Number.isFinite(sizeBytes) || !Number.isFinite(deviceBytes) || deviceBytes <= 0) {
          return "⚠️ May exceed this device's memory";
        }
        const sizeGb = sizeBytes / 1024 ** 3;
        const deviceGb = deviceBytes / 1024 ** 3;
        const format = (value) => (value >= 10 ? value.toFixed(0) : value.toFixed(1));
        return `⚠️ ~${format(sizeGb)} GB vs ${format(deviceGb)} GB device memory`;
      };

      const getModelDisplayName = (model) => {
        return (
          model?.display_name
          ?? model?.name
          ?? model?.model_name
          ?? model?.model_id
          ?? "Model"
        );
      };

      const preferInstructionalModel = (models) => {
        if (!Array.isArray(models)) return null;
        const instructPattern = /(instruct|it)/i;
        return (
          models.find(model => {
            const identifier = `${model?.model_id ?? ""} ${model?.model_name ?? ""}`;
            return instructPattern.test(identifier);
          }) ?? models[0] ?? null
        );
      };

      const pickInitialModel = (models, storedId) => {
        if (!Array.isArray(models) || !models.length) return null;
        if (storedId) {
          const stored = models.find(model => model.model_id === storedId);
          if (stored) {
            return stored;
          }
        }
        const budgetAware = getSortedModelsBySize(filterModelsByMemoryBudget(models));
        const preferred = preferInstructionalModel(budgetAware);
        return preferred ?? budgetAware[0] ?? models[0] ?? null;
      };

      const findFallbackModel = (model, attempted = new Set()) => {
        const sorted = getSortedModelsBySize();
        if (!sorted.length) return null;
        const currentId = model?.model_id;
        const currentIndex = sorted.findIndex(item => item.model_id === currentId);
        const isCandidateEligible = (candidate) => {
          if (!candidate) return false;
          if (candidate.model_id === currentId) return false;
          if (attempted.has(candidate.model_id)) return false;
          return true;
        };

        if (currentIndex > -1) {
          const currentScore = getModelSizeScore(model);
          for (let i = currentIndex - 1; i >= 0; i -= 1) {
            const candidate = sorted[i];
            if (isCandidateEligible(candidate)) {
              return candidate;
            }
          }
          for (let i = currentIndex + 1; i < sorted.length; i += 1) {
            const candidate = sorted[i];
            if (!candidate) continue;
            const candidateScore = getModelSizeScore(candidate);
            if (
              Number.isFinite(currentScore)
              && Number.isFinite(candidateScore)
              && candidateScore > currentScore
            ) {
              break;
            }
            if (isCandidateEligible(candidate)) {
              return candidate;
            }
          }
          return null;
        }

        for (const candidate of sorted) {
          if (isCandidateEligible(candidate)) {
            return candidate;
          }
        }
        return null;
      };

      const buildModelOptionLabel = (model) => {
        const name = getModelDisplayName(model);
        const sizeBytes = getModelSizeBytes(model);
        const contextTokens = getModelContextTokens(model);
        const notes = [];
        if (sizeBytes) {
          notes.push(`≈${formatBytesReadable(sizeBytes)}`);
        }
        if (contextTokens) {
          notes.push(`${contextTokens.toLocaleString()} token ctx`);
        }
        if (isModelLikelyTooLargeForDevice(model)) {
          notes.push("⚠️ heavy for this device");
        }
        return notes.length ? `${name} (${notes.join(" · ")})` : name;
      };

      const updateModelMetadata = (model) => {
        if (!model) {
          if (statusMetaEl) {
            statusMetaEl.classList.remove("warning");
          }
          setStatusMeta("");
          return;
        }
        const parts = [];
        if (currentInitStage) {
          parts.push(currentInitStage);
        }
        const contextTokens = getModelContextTokens(model);
        if (Number.isFinite(contextTokens)) {
          parts.push(`Context ${contextTokens.toLocaleString()} tokens`);
        }
        const sizeBytes = getModelSizeBytes(model);
        if (sizeBytes) {
          parts.push(`≈${formatBytesReadable(sizeBytes)}`);
        }
        const risk = describeModelSizeRisk(model);
        if (risk) {
          parts.push(risk);
          if (statusMetaEl) {
            statusMetaEl.classList.add("warning");
          }
        } else if (statusMetaEl) {
          statusMetaEl.classList.remove("warning");
        }
        setStatusMeta(parts.join(" · "));
      };

      const loadEngineForModel = async (model, { userInitiated = false, attemptedModelIds = new Set() } = {}) => {
        if (!model?.model_id) {
          reportEngineFailure(
            "No compatible model available.",
            "I couldn't find a model that fits this device. Please close other apps and refresh to try again."
          );
          return false;
        }

        if (!(attemptedModelIds instanceof Set)) {
          attemptedModelIds = new Set();
        }

        attemptedModelIds.add(model.model_id);
        const targetModelId = model.model_id;
        const displayName = getModelDisplayName(model);
        queuedModelId = null;
        pendingModelReload = null;
        currentInitStage = "";
        engineInitializing = true;
        engineInitFailed = false;
        loadingModelId = targetModelId;
        sendBtn.disabled = true;
        if (modelSelect) {
          modelSelect.disabled = true;
        }

        updateModelMetadata(model);
        updateStatus(userInitiated ? `Switching to ${displayName}` : `Loading ${displayName}`);

        try {
          await disposeEngine();
          activeModelId = null;

          const webllm = await ensureWebLLMModule();

          engine = await webllm.CreateMLCEngine(targetModelId, {
            initProgressCallback: (p) => {
              const progressRaw = Number(p?.progress);
              const progress = Number.isFinite(progressRaw) ? Math.floor(progressRaw * 100) : NaN;
              const stageLabel = formatStageLabel(p?.text || p?.stage || "");
              const statusText = Number.isFinite(progress) && progress > 0
                ? `${progress}%`
                : "Loading";
              currentInitStage = stageLabel;
              updateStatus(statusText);
              updateModelMetadata(model);
            }
          });

          try {
            const chatCompletionCreate = engine?.chat?.completions?.create;
            if (typeof chatCompletionCreate !== "function") {
              throw new Error("Engine missing chat.completions.create");
            }
            await chatCompletionCreate({
              messages: [
                {
                  role: "system",
                  content: "You are a readiness probe ensuring the Dungeon Master engine can process prompts."
                },
                {
                  role: "user",
                  content: "Reply with READY so we know the engine is awake."
                }
              ],
              stream: false,
              max_tokens: 1,
              temperature: 0
            });
          } catch (selfTestError) {
            console.error("Engine health check failed", selfTestError);
            await disposeEngine();
            reportEngineFailure(
              `Health check failed for ${displayName}`,
              `My quick engine health check for ${displayName} failed. Please try again or pick another model.`
            );
            return false;
          }

          activeModelId = targetModelId;
          const readyLabel = `Ready to answer questions · ${displayName}`;
          updateStatus(readyLabel, "ready");
          currentInitStage = "";
          updateModelMetadata(model);
          sendBtn.disabled = false;
          engineInitFailed = false;
          return true;
        } catch (error) {
          console.error(error);
          engine = null;
          const fallbackModel = findFallbackModel(model, attemptedModelIds);
          if (fallbackModel && fallbackModel.model_id !== targetModelId) {
            const fallbackDisplayName = getModelDisplayName(fallbackModel);
            if (modelSelect) {
              modelSelect.value = fallbackModel.model_id;
            }
            safeStorage.set(STORAGE_KEYS.model, fallbackModel.model_id);
            currentInitStage = "";
            updateModelMetadata(fallbackModel);
            const introMessage = userInitiated
              ? `I couldn't load ${displayName} on this device, so I'm switching to ${fallbackDisplayName}.`
              : `The default model looks too heavy for this device. Trying ${fallbackDisplayName} instead.`;
            appendMessage("assistant", introMessage);
            updateStatus(`Retrying with ${fallbackDisplayName}`);
            return await loadEngineForModel(fallbackModel, {
              userInitiated: false,
              attemptedModelIds
            });
          }
          const statusText = userInitiated
            ? `Failed to load ${displayName}`
            : "Failed to load WebLLM. Refresh and ensure WebGPU is enabled.";
          const logText = userInitiated
            ? `I couldn't switch to ${displayName}. Please try again in a moment or refresh so I can retry automatically.`
            : "I couldn't initialize the model. Please refresh after confirming WebGPU is enabled, then I'll be ready to help.";
          currentInitStage = "";
          updateModelMetadata(model);
          reportEngineFailure(statusText, logText);
          return false;
        } finally {
          currentInitStage = "";
          updateModelMetadata(model);
          engineInitializing = false;
          loadingModelId = null;
          if (modelSelect) {
            modelSelect.disabled = false;
          }
          if (queuedModelId && queuedModelId !== activeModelId) {
            const nextModel = availableModels.find(item => item.model_id === queuedModelId);
            queuedModelId = null;
            if (nextModel) {
              loadEngineForModel(nextModel, { userInitiated: true });
            }
          }
        }
      };

      const getSelectedModel = () => {
        if (!availableModels.length) return null;
        const selectedId = modelSelect?.value;
        if (selectedId) {
          const match = availableModels.find(model => model.model_id === selectedId);
          if (match) return match;
        }
        return availableModels[0];
      };

      modelSelect?.addEventListener("change", () => {
        const model = getSelectedModel();
        if (!model) return;
        const { model_id: modelId } = model;
        safeStorage.set(STORAGE_KEYS.model, modelId);
        updateModelMetadata(model);

        if (modelId === activeModelId && !engineInitFailed) {
          return;
        }

        if (engineInitializing) {
          if (modelId !== loadingModelId) {
            queuedModelId = modelId;
          }
          return;
        }

        const isGenerating = statusEl?.classList.contains("generating");
        if (isGenerating) {
          pendingModelReload = modelId;
          showPromptToast?.(
            `Switching to ${getModelDisplayName(model)} after this reply finishes.`
          );
          return;
        }

        loadEngineForModel(model, { userInitiated: true });
      });

      const messages = [
        {
          role: "system",
          content: `You are an expert Dungeon Master and rules archivist for every edition of Dungeons & Dragons.
Provide concise, citation-style answers drawing on SRDs, rulebooks, and designer commentary.
If content might differ between editions, call out each edition explicitly.
Always encourage players to consult the cited books for full rules text.
Avoid reproducing copyrighted text verbatim; summarize mechanics instead.
Stay family friendly and inclusive.`
        }
      ];

      function openAskTab() {
        const askButton = document.querySelector('nav button[data-target="ask"]');
        if (askButton && !askButton.classList.contains("active")) {
          askButton.click();
        }
      }

      const createMessageElements = (role, content = "") => {
        const container = document.createElement("article");
        container.className = `message ${role}`;
        container.setAttribute("role", "article");
        const roleLabel =
          role === "assistant"
            ? "Dungeon Master response"
            : role === "user"
            ? "Player message"
            : "System message";
        container.setAttribute("aria-label", roleLabel);

        const bubble = document.createElement("div");
        bubble.className = `bubble ${role}`;
        bubble.textContent = content;
        container.appendChild(bubble);

        return { container, bubble };
      };

      const appendMessage = (role, content) => {
        const { container } = createMessageElements(role, content);
        logEl.appendChild(container);
        logEl.scrollTop = logEl.scrollHeight;
      };

      appendMessage("assistant", "Welcome, adventurer! I'm your digital Dungeon Master. Ask me about any rule, edition, or item and I'll guide you to the right table, chapter, or adjudication.");

      const setLogBusy = (busy) => {
        if (logEl) {
          logEl.setAttribute("aria-busy", busy ? "true" : "false");
        }
      };

      const updateStatus = (text, state = "") => {
        statusEl.classList.remove("ready", "generating");
        if (state) statusEl.classList.add(state);
        statusEl.querySelector("strong").textContent = text;
        setLogBusy(state === "generating");
      };

      const reportEngineFailure = (statusText, logText) => {
        updateStatus(statusText);
        sendBtn.disabled = true;
        if (!engineInitFailed && logText) {
          appendMessage("assistant", logText);
        }
        engineInitFailed = true;
      };

      let engine;
      let engineInitFailed = false;
      let engineInitializing = false;

      async function setupWebLLM() {
        if (!logEl || !promptEl || !sendBtn || !statusEl) {
          return;
        }

        if (engineInitializing || loadingModelId) {
          return;
        }

        if (typeof navigator === "undefined" || !navigator?.gpu) {
          reportEngineFailure(
            "WebGPU is unavailable in this browser. Try Chrome, Edge, or another WebGPU-enabled browser.",
            "I can't spin up my DM brain because WebGPU isn't available in this browser. Try Chrome, Edge, or another WebGPU-enabled option and reload."
          );
          return;
        }

        if (modelSelect) {
          modelSelect.disabled = true;
        }

        let runtime;
        try {
          runtime = await ensureWebLLMModule();
        } catch (error) {
          console.error(error);
          reportEngineFailure(
            "Failed to download the WebLLM runtime. Check your connection and refresh.",
            "I wasn't able to download the WebLLM runtime. Check your connection, refresh the page, and I'll try again."
          );
          if (modelSelect) {
            modelSelect.disabled = false;
          }
          return;
        }

        availableModels = Array.isArray(runtime?.prebuiltAppConfig?.model_list)
          ? runtime.prebuiltAppConfig.model_list
          : [];

        if (!availableModels.length) {
          reportEngineFailure(
            "No models available to load.",
            "I couldn't find any compatible models to initialize. Please refresh once your connection is stable."
          );
          if (modelSelect) {
            modelSelect.disabled = false;
          }
          return;
        }

        const storedModelId = safeStorage.get(STORAGE_KEYS.model);
        const initialModel = pickInitialModel(availableModels, storedModelId);

        if (modelSelect) {
          modelSelect.innerHTML = "";
          const fragment = document.createDocumentFragment();
          availableModels.forEach(model => {
            const option = document.createElement("option");
            option.value = model.model_id;
            option.textContent = buildModelOptionLabel(model);
            if (isModelLikelyTooLargeForDevice(model)) {
              option.dataset.heavy = "true";
              option.title = "This model may exceed your device's available memory";
            }
            fragment.appendChild(option);
          });
          modelSelect.appendChild(fragment);
          if (initialModel) {
            modelSelect.value = initialModel.model_id;
          }
        }

        const selectedModel = modelSelect ? getSelectedModel() : initialModel ?? availableModels[0];
        if (!selectedModel) {
          reportEngineFailure(
            "No compatible model available.",
            "I couldn't find a model that fits this device. Please close other apps and refresh to try again."
          );
          if (modelSelect) {
            modelSelect.disabled = false;
          }
          return;
        }

        safeStorage.set(STORAGE_KEYS.model, selectedModel.model_id);
        updateModelMetadata(selectedModel);

        if (modelSelect) {
          modelSelect.disabled = false;
        }

        await loadEngineForModel(selectedModel);
      }

      async function streamReply(messages, opts = {}) {
        if (!engine) {
          if (!engineInitFailed) {
            appendMessage("assistant", "The DM brain isn't ready yet. Please wait for the engine to finish loading.");
          }
          const error = new Error(engineInitFailed ? "engine-init-failed" : "engine-not-ready");
          error.name = "WebLLMUnavailableError";
          error.code = engineInitFailed ? "engine-init-failed" : "engine-not-ready";
          throw error;
        }

        const generationOpts = getGenerationOptions();
        const chunks = await engine.chat.completions.create({
          messages,
          stream: true,
          stream_options: { include_usage: true },
          ...generationOpts,
          ...opts
        });
        let out = "";
        let streamMessage;
        for await (const c of chunks) {
          const delta = c.choices?.[0]?.delta?.content || "";
          out += delta;
          if (delta) {
            if (!streamMessage) {
              streamMessage = createMessageElements("assistant");
              logEl.appendChild(streamMessage.container);
            }
            streamMessage.bubble.textContent += delta;
            logEl.scrollTop = logEl.scrollHeight;
          }
          updateStatus("Generating", "generating");
        }
        return out.trim();
      }

      const sendPrompt = async () => {
        const text = promptEl.value.trim();
        if (!text) return;
        promptEl.value = "";
        appendMessage("user", text);
        messages.push({ role: "user", content: text });
        sendBtn.disabled = true;
        try {
          setLogBusy(true);
          const reply = await streamReply(messages);
          if (reply) {
            messages.push({ role: "assistant", content: reply });
          }
          updateStatus("Ready", "ready");
        } catch (error) {
          console.error(error);
          if (error?.code === "engine-not-ready") {
            updateStatus("Loading");
          } else if (error?.code === "engine-init-failed") {
            updateStatus("Engine failed to start");
          } else {
            appendMessage("assistant", "I ran into an error generating that response. Please try again.");
            updateStatus("Encountered an error");
          }
        } finally {
          const isGenerating = statusEl.classList.contains("generating");
          if (!isGenerating) {
            setLogBusy(false);
          }

          if (
            pendingModelReload
            && !engineInitializing
            && !isGenerating
          ) {
            const nextModelId = pendingModelReload;
            pendingModelReload = null;
            const nextModel = availableModels.find(model => model.model_id === nextModelId);
            if (nextModel) {
              await loadEngineForModel(nextModel, { userInitiated: true });
            }
          }

          sendBtn.disabled = !engine;
        }
      };

      const handlePromptPrefill = (prompt) => {
        if (!promptEl) return;
        openAskTab();
        promptEl.value = prompt;
        promptEl.focus();
        document.getElementById("ask")?.scrollIntoView({ behavior: "smooth", block: "start" });

        if (!autoSendQuickPrompts) {
          showPromptToast("Prompt ready to edit.");
          return;
        }

        if (engineInitFailed) {
          showPromptToast("Engine failed to load. Prompt saved for later.");
          return;
        }

        if (!engine) {
          showPromptToast("Prompt queued—engine is still loading.");
          return;
        }

        if (sendBtn.disabled) {
          showPromptToast("Prompt queued until the current reply finishes.");
          return;
        }

        showPromptToast("Prompt sent automatically.");
        sendPrompt();
      };

      function wirePromptPrefill() {
        document.addEventListener("click", (event) => {
          const trigger = event.target.closest("[data-prompt]");
          if (!trigger) return;
          const prompt = trigger.dataset.prompt?.trim();
          if (!prompt) return;
          if (trigger.tagName === "A") {
            event.preventDefault();
          }
          handlePromptPrefill(prompt);
        });
      }

      sendBtn.addEventListener("click", sendPrompt);
      promptEl.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" && !ev.shiftKey) {
          ev.preventDefault();
          sendPrompt();
        }
      });

      wirePromptPrefill();

      setupWebLLM().catch(err => {
        console.error("WebLLM setup failed", err);
      });

    </script>
  </body>
</html>
