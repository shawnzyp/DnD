<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Compendium</title>
  <script src="/js/loader.js" defer></script>
  <style>
    :root {
      color-scheme: dark light;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --bg: #0b1014;
      --fg: #f5f8fd;
      --muted: rgba(245, 248, 253, 0.65);
      --surface: rgba(245, 248, 253, 0.05);
      --accent: #4cc2ff;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      position: sticky;
      top: 0;
      padding: 1rem 1.25rem 0.5rem;
      background: linear-gradient(180deg, rgba(11,16,20,0.95) 0%, rgba(11,16,20,0.55) 100%);
      backdrop-filter: blur(18px);
      z-index: 3;
    }
    h1 {
      margin: 0 0 0.5rem;
      font-size: 1.35rem;
    }
    .pack-meta {
      margin: 0;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .pack-controls {
      margin: 0.75rem 0 0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }
    .pack-controls .pack-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .pill-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      padding: 0.45rem 0.9rem;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: var(--fg);
      font-size: 0.72rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      cursor: pointer;
      transition: background 140ms ease, border-color 140ms ease, transform 140ms ease;
    }
    .pill-button:hover {
      background: rgba(76, 194, 255, 0.2);
      border-color: rgba(76, 194, 255, 0.35);
      transform: translateY(-1px);
    }
    .pill-button:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }
    .pack-status {
      margin: 0;
      flex: 1;
      min-width: 160px;
      font-size: 0.72rem;
      color: var(--muted);
    }
    .search-shell {
      display: grid;
      gap: 0.5rem;
    }
    .search-shell input[type="search"] {
      width: 100%;
      padding: 0.8rem 1rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.04);
      color: inherit;
      font-size: 0.95rem;
    }
    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding-bottom: 0.35rem;
    }
    .chip {
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 0.75rem;
      letter-spacing: 0.02em;
    }
    .chip[aria-pressed="true"] {
      background: rgba(76, 194, 255, 0.22);
      border-color: rgba(76, 194, 255, 0.45);
      color: var(--fg);
    }
    main {
      flex: 1;
      position: relative;
      overflow: hidden;
    }
    #list-viewport {
      height: calc(100vh - 210px);
      min-height: 360px;
      overflow-y: auto;
      padding: 0 0.75rem 6rem;
    }
    @media (min-height: 740px) {
      #list-viewport {
        height: calc(100vh - 240px);
      }
    }
    .virtual-list {
      position: relative;
    }
    .virtual-row {
      position: absolute;
      left: 0;
      right: 0;
      padding: 0.75rem 0.5rem;
      transform: translateZ(0);
    }
    .entry {
      border-radius: 0.85rem;
      padding: 0.75rem 1rem;
      background: var(--surface);
      border: 1px solid rgba(255,255,255,0.08);
      display: grid;
      gap: 0.3rem;
    }
    .entry h3 {
      margin: 0;
      font-size: 1rem;
    }
    .entry small {
      color: var(--muted);
      font-size: 0.75rem;
    }
    .entry button {
      justify-self: flex-start;
      padding: 0.35rem 0.7rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.15);
      background: rgba(255,255,255,0.08);
      color: inherit;
      font-size: 0.7rem;
    }
    #detail-drawer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(11,16,20,0.98);
      border-radius: 1.1rem 1.1rem 0 0;
      border-top: 1px solid rgba(255,255,255,0.08);
      padding: 1rem 1.25rem calc(env(safe-area-inset-bottom) + 1.25rem);
      transform: translateY(100%);
      transition: transform 220ms ease;
      max-height: 65vh;
      overflow-y: auto;
      box-shadow: 0 -1.5rem 3rem -1.5rem rgba(0,0,0,0.5);
      z-index: 5;
    }
    #detail-drawer.open {
      transform: translateY(0);
    }
    #detail-drawer header {
      position: sticky;
      top: 0;
      background: inherit;
      padding: 0 0 0.75rem;
      margin-bottom: 0.5rem;
    }
    #detail-drawer h2 {
      margin: 0;
      font-size: 1.1rem;
    }
    #detail-body {
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.5;
      white-space: pre-wrap;
    }
    .tab-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      padding: 0.45rem calc(env(safe-area-inset-left) + 0.85rem) calc(env(safe-area-inset-bottom) + 0.6rem);
      background: linear-gradient(180deg, rgba(11,16,20,0.35) 0%, rgba(11,16,20,0.98) 80%);
      backdrop-filter: blur(16px);
      border-top: 1px solid rgba(255,255,255,0.08);
      z-index: 6;
      gap: 0.75rem;
    }
    .tab-bar a {
      flex: 1;
      text-align: center;
      text-decoration: none;
      color: var(--muted);
      font-size: 0.78rem;
      padding: 0.65rem 0.5rem;
      border-radius: 0.75rem;
    }
    .tab-bar a.active {
      background: rgba(76, 194, 255, 0.2);
      color: var(--fg);
      font-weight: 600;
    }
    .legal-link {
      padding: 0.75rem 1.25rem;
      font-size: 0.75rem;
      color: var(--muted);
      text-align: center;
    }
    .legal-link a {
      color: inherit;
    }
  </style>
</head>
<body>
  <header>
    <h1>Compendium</h1>
    <p id="compendium-pack-meta" class="pack-meta" aria-live="polite">Loading SRD entries…</p>
    <div class="pack-controls">
      <div class="pack-buttons">
        <button type="button" id="compendium-import-file" class="pill-button">Import JSON</button>
        <button type="button" id="compendium-import-url" class="pill-button">Add from URL</button>
        <button type="button" id="compendium-reload-packs" class="pill-button">Reload Packs</button>
      </div>
      <p id="compendium-pack-status" class="pack-status" aria-live="polite"></p>
    </div>
    <input type="file" id="compendium-pack-file" accept="application/json" hidden />
    <div class="search-shell">
      <input type="search" id="search-input" placeholder="Search spells, feats, and rules" />
      <div class="chips" role="group" aria-label="Filters">
        <button class="chip" data-filter="spell" aria-pressed="false">Spell</button>
        <button class="chip" data-filter="feat" aria-pressed="false">Feat</button>
        <button class="chip" data-filter="item" aria-pressed="false">Item</button>
        <button class="chip" data-filter="rule" aria-pressed="false">Rule</button>
      </div>
    </div>
  </header>
  <main>
    <div id="list-viewport">
      <div id="virtual-list" class="virtual-list"></div>
    </div>
  </main>
  <p class="legal-link">
    <a href="/LEGAL/NOTICE.txt" target="_blank" rel="noopener noreferrer">SRD 5.1 licensing notice</a>
  </p>
  <aside id="detail-drawer" aria-modal="true" role="dialog" aria-hidden="true">
    <header>
      <h2 id="detail-title">Detail</h2>
      <p id="detail-type" style="margin:0;color:var(--muted);font-size:0.8rem;"></p>
    </header>
    <div id="detail-body"></div>
    <button id="favorite-toggle" style="margin-top:1rem;padding:0.6rem 1rem;border-radius:0.85rem;border:none;background:var(--accent);color:#04121b;font-weight:600;">Save to Favorites</button>
  </aside>
  <nav class="tab-bar">
    <a href="/index.html">Home</a>
    <a href="/builder/index.html">Builder</a>
    <a href="/compendium/index.html" class="active">Compendium</a>
  </nav>
  <script>
    const FAVORITES_KEY = 'dndCompendiumFavorites';
    const TYPE_LABELS = { spell: 'Spell', feat: 'Feat', item: 'Item', rule: 'Rule' };

    const viewport = document.getElementById('list-viewport');
    const list = document.getElementById('virtual-list');
    const rowHeight = 132;
    let data = [];
    let filtered = [];
    let startIndex = 0;
    let endIndex = 0;
    let favorites = loadFavorites();
    let packData = {
      packs: [],
      spells: [],
      feats: [],
      items: [],
      rules: []
    };

    function setPackData(value) {
      packData = {
        packs: Array.isArray(value?.packs) ? value.packs : [],
        spells: Array.isArray(value?.spells) ? value.spells : [],
        feats: Array.isArray(value?.feats) ? value.feats : [],
        items: Array.isArray(value?.items) ? value.items : [],
        rules: Array.isArray(value?.rules) ? value.rules : []
      };
      window.dndCompendiumData = packData;
    }

    function getPackData() {
      return packData;
    }

    function setPackStatus(message) {
      const status = document.getElementById('compendium-pack-status');
      if (status) {
        status.textContent = message || '';
      }
    }

    async function hydratePackData() {
      if (window.dnd && typeof window.dnd.getCompendiumData === 'function') {
        try {
          const dataset = await window.dnd.getCompendiumData();
          setPackData(dataset);
        } catch (error) {
          console.warn('Failed to load compendium packs', error);
          const fallback = window.dndCompendiumData || window.dndData || packData;
          setPackData(fallback);
        }
      } else if (window.dndData) {
        setPackData(window.dndData);
      }
      rebuildFromData();
    }

    function subscribeToPackChanges() {
      if (window.dnd && typeof window.dnd.onChange === 'function') {
        window.dnd.onChange((detail) => {
          if (detail && detail.compendium) {
            setPackData(detail.compendium);
            rebuildFromData();
          }
        });
      } else {
        window.addEventListener('dnd-data-changed', () => {
          const fallback = window.dndCompendiumData || window.dndData || packData;
          setPackData(fallback);
          rebuildFromData();
        });
      }
    }

    function wirePackControls() {
      const fileInput = document.getElementById('compendium-pack-file');
      const importFileButton = document.getElementById('compendium-import-file');
      const importUrlButton = document.getElementById('compendium-import-url');
      const reloadButton = document.getElementById('compendium-reload-packs');

      if (importFileButton && fileInput) {
        importFileButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', async (event) => {
          const [file] = event.target.files || [];
          if (!file || !window.dnd || typeof window.dnd.importPackFile !== 'function') {
            setPackStatus('Pack loader unavailable.');
            return;
          }
          setPackStatus(`Importing ${file.name}…`);
          try {
            await window.dnd.importPackFile(file);
            setPackStatus(`Imported ${file.name}`);
          } catch (error) {
            console.error('Failed to import pack', error);
            setPackStatus('Import failed. Check console for details.');
          } finally {
            fileInput.value = '';
            setTimeout(() => setPackStatus(''), 4000);
          }
        });
      }

      if (importUrlButton) {
        importUrlButton.addEventListener('click', async () => {
          if (!window.dnd || typeof window.dnd.importPackFromUrl !== 'function') {
            setPackStatus('Pack loader unavailable.');
            return;
          }
          const url = window.prompt('Enter the URL of a pack manifest JSON file:');
          if (!url) return;
          setPackStatus('Fetching pack…');
          try {
            await window.dnd.importPackFromUrl(url);
            setPackStatus('Pack added from URL.');
          } catch (error) {
            console.error('Failed to import pack from URL', error);
            setPackStatus('Import failed. Check console for details.');
          } finally {
            setTimeout(() => setPackStatus(''), 4000);
          }
        });
      }

      if (reloadButton) {
        reloadButton.addEventListener('click', async () => {
          if (!window.dnd || typeof window.dnd.reload !== 'function') {
            setPackStatus('Pack loader unavailable.');
            return;
          }
          setPackStatus('Reloading packs…');
          try {
            await window.dnd.reload();
            setPackStatus('Packs reloaded.');
          } catch (error) {
            console.error('Failed to reload packs', error);
            setPackStatus('Reload failed.');
          } finally {
            setTimeout(() => setPackStatus(''), 3000);
          }
        });
      }
    }

    function loadFavorites() {
      try {
        const raw = localStorage.getItem(FAVORITES_KEY);
        return raw ? JSON.parse(raw) : { ids: [] };
      } catch (err) {
        console.warn('Failed to read favorites', err);
        return { ids: [] };
      }
    }

    function saveFavorites() {
      try {
        localStorage.setItem(FAVORITES_KEY, JSON.stringify(favorites));
      } catch (err) {
        console.warn('Failed to save favorites', err);
      }
      window.dispatchEvent(new CustomEvent('dnd-state-changed'));
    }

    function summarise(text) {
      const value = (text || '').trim();
      if (!value) return 'Open the detail drawer for full rules text.';
      return value.length > 160 ? `${value.slice(0, 157)}…` : value;
    }

    function formatSourceBadge(source) {
      if (!source) return '';
      const parts = [];
      if (source.name) parts.push(source.name);
      if (source.edition) parts.push(source.edition);
      return parts.join(' · ');
    }

    function formatSourceDetail(source) {
      if (!source) return '';
      const parts = [];
      if (source.name) parts.push(source.name);
      if (source.edition) parts.push(source.edition);
      if (source.license) parts.push(source.license);
      return parts.length ? `Source: ${parts.join(' • ')}` : '';
    }

    function buildSpellEntry(spell) {
      const description = (spell.description || '').trim();
      const badge = formatSourceBadge(spell.source);
      const subtitleParts = [TYPE_LABELS.spell];
      if (typeof spell.level === 'number') subtitleParts.push(`Level ${spell.level}`);
      if (spell.school) subtitleParts.push(spell.school);
      if (badge) subtitleParts.push(badge);
      const detailParts = [
        `${spell.school || 'Spell'} • Level ${typeof spell.level === 'number' ? spell.level : 0}`,
        `Casting Time: ${spell.casting_time || '1 action'}`,
        `Range: ${spell.range || 'Self'}`,
        `Components: ${spell.components || 'V, S'}`,
        `Duration: ${spell.duration || 'Instantaneous'}`,
        '',
        description,
        '',
        formatSourceDetail(spell.source)
      ].filter(Boolean);
      return {
        id: `spell:${spell.slug}`,
        slug: spell.slug,
        name: spell.name,
        type: 'spell',
        level: spell.level ?? 0,
        summary: summarise(description),
        detail: detailParts.join('\n'),
        subtitle: subtitleParts.filter(Boolean).join(' · '),
        searchText: [spell.name, spell.school, spell.casting_time, spell.range, spell.components, description, formatSourceDetail(spell.source)].filter(Boolean).join(' ').toLowerCase()
      };
    }

    function buildFeatEntry(feat) {
      const description = (feat.description || '').trim();
      const badge = formatSourceBadge(feat.source);
      const subtitleParts = [TYPE_LABELS.feat];
      if (badge) subtitleParts.push(badge);
      const detailParts = [TYPE_LABELS.feat, '', description, '', formatSourceDetail(feat.source)].filter(Boolean);
      return {
        id: `feat:${feat.slug}`,
        slug: feat.slug,
        name: feat.name,
        type: 'feat',
        summary: summarise(description),
        detail: detailParts.join('\n'),
        subtitle: subtitleParts.join(' · '),
        searchText: [feat.name, description, formatSourceDetail(feat.source)].filter(Boolean).join(' ').toLowerCase()
      };
    }

    function buildItemEntry(item) {
      const description = (item.description || '').trim();
      const badge = formatSourceBadge(item.source);
      const subtitleParts = [TYPE_LABELS.item];
      if (item.category) subtitleParts.push(item.category);
      if (badge) subtitleParts.push(badge);
      const detailParts = [
        `${item.category || 'Item'} • Cost ${item.cost || '—'} • Weight ${item.weight || '—'}`,
        '',
        description,
        '',
        formatSourceDetail(item.source)
      ].filter(Boolean);
      return {
        id: `item:${item.slug}`,
        slug: item.slug,
        name: item.name,
        type: 'item',
        summary: summarise(description),
        detail: detailParts.join('\n'),
        subtitle: subtitleParts.join(' · '),
        searchText: [item.name, item.category, item.cost, item.weight, description, formatSourceDetail(item.source)].filter(Boolean).join(' ').toLowerCase()
      };
    }

    function buildRuleEntry(rule) {
      const description = (rule.description || '').trim();
      const badge = formatSourceBadge(rule.source);
      const subtitleParts = [TYPE_LABELS.rule];
      if (rule.category) subtitleParts.push(rule.category);
      if (badge) subtitleParts.push(badge);
      const detailParts = [rule.category || TYPE_LABELS.rule, '', description, '', formatSourceDetail(rule.source)].filter(Boolean);
      return {
        id: `rule:${rule.slug}`,
        slug: rule.slug,
        name: rule.name,
        type: 'rule',
        summary: summarise(description),
        detail: detailParts.join('\n'),
        subtitle: subtitleParts.join(' · '),
        searchText: [rule.name, rule.category, description, formatSourceDetail(rule.source)].filter(Boolean).join(' ').toLowerCase()
      };
    }

    function buildEntries() {
      const { spells = [], feats = [], items = [], rules = [] } = getPackData();
      const entries = [];
      spells.forEach(spell => entries.push(buildSpellEntry(spell)));
      feats.forEach(feat => entries.push(buildFeatEntry(feat)));
      items.forEach(item => entries.push(buildItemEntry(item)));
      rules.forEach(rule => entries.push(buildRuleEntry(rule)));
      return entries.sort((a, b) => a.name.localeCompare(b.name, 'en', { sensitivity: 'base' }));
    }

    function updatePackMeta() {
      const target = document.getElementById('compendium-pack-meta');
      if (!target) return;
      const { packs = [] } = getPackData();
      if (!packs.length) {
        target.textContent = 'No licensed content packs loaded.';
        return;
      }
      const text = packs.map(pack => {
        const edition = pack.edition ? ` · ${pack.edition}` : '';
        const license = pack.license ? ` • ${pack.license}` : '';
        return `${pack.name}${edition}${license}`;
      }).join(' | ');
      target.textContent = `Loaded packs: ${text}`;
    }

    function rebuildFromData() {
      data = buildEntries();
      applyFilters();
      updatePackMeta();
    }

    function applyFilters() {
      const query = document.getElementById('search-input').value.trim().toLowerCase();
      const activeFilters = Array.from(document.querySelectorAll('.chip[aria-pressed="true"]')).map(chip => chip.dataset.filter);
      filtered = data.filter(entry => {
        const matchesQuery = !query || entry.searchText.includes(query);
        const matchesFilter = !activeFilters.length || activeFilters.includes(entry.type);
        return matchesQuery && matchesFilter;
      });
      list.style.height = filtered.length ? `${filtered.length * rowHeight}px` : '0px';
      renderVirtualRows();
    }

    function renderVirtualRows() {
      const scrollTop = viewport.scrollTop;
      const viewportHeight = viewport.clientHeight;
      const buffer = 4;
      startIndex = Math.max(0, Math.floor(scrollTop / rowHeight) - buffer);
      endIndex = Math.min(filtered.length, Math.ceil((scrollTop + viewportHeight) / rowHeight) + buffer);

      list.innerHTML = '';
      for (let i = startIndex; i < endIndex; i++) {
        const entry = filtered[i];
        const row = document.createElement('div');
        row.className = 'virtual-row';
        row.style.top = `${i * rowHeight}px`;

        const article = document.createElement('article');
        article.className = 'entry';
        article.dataset.id = entry.id;
        article.dataset.type = entry.type;

        const title = document.createElement('h3');
        title.textContent = entry.name;
        article.appendChild(title);

        const subtitle = document.createElement('small');
        subtitle.textContent = entry.subtitle;
        article.appendChild(subtitle);

        const summary = document.createElement('p');
        summary.style.margin = '0';
        summary.style.color = 'var(--muted)';
        summary.style.fontSize = '0.78rem';
        summary.textContent = entry.summary;
        article.appendChild(summary);

        const button = document.createElement('button');
        button.type = 'button';
        button.dataset.action = 'details';
        button.textContent = 'Quick look';
        article.appendChild(button);

        row.appendChild(article);
        list.appendChild(row);
      }
    }

    function openDetail(id) {
      const entry = filtered.find(item => item.id === id);
      if (!entry) return;
      const drawer = document.getElementById('detail-drawer');
      document.getElementById('detail-title').textContent = entry.name;
      document.getElementById('detail-type').textContent = entry.subtitle;
      const body = document.getElementById('detail-body');
      body.textContent = entry.detail;
      const favoriteToggle = document.getElementById('favorite-toggle');
      favoriteToggle.dataset.id = entry.id;
      const isFav = favorites.ids.includes(entry.id);
      favoriteToggle.textContent = isFav ? 'Remove Favorite' : 'Save to Favorites';
      drawer.classList.add('open');
      drawer.setAttribute('aria-hidden', 'false');
    }

    function closeDetail() {
      const drawer = document.getElementById('detail-drawer');
      drawer.classList.remove('open');
      drawer.setAttribute('aria-hidden', 'true');
    }

    function toggleFavorite(id) {
      const index = favorites.ids.indexOf(id);
      if (index >= 0) {
        favorites.ids.splice(index, 1);
      } else {
        favorites.ids.push(id);
      }
      saveFavorites();
      document.getElementById('favorite-toggle').textContent = favorites.ids.includes(id) ? 'Remove Favorite' : 'Save to Favorites';
    }

    viewport.addEventListener('scroll', () => {
      requestAnimationFrame(renderVirtualRows);
    });

    document.getElementById('search-input').addEventListener('input', () => {
      requestAnimationFrame(applyFilters);
    });

    document.querySelector('.chips').addEventListener('click', (event) => {
      const button = event.target.closest('.chip');
      if (!button) return;
      const pressed = button.getAttribute('aria-pressed') === 'true';
      button.setAttribute('aria-pressed', String(!pressed));
      requestAnimationFrame(applyFilters);
    });

    list.addEventListener('click', (event) => {
      const button = event.target.closest('button[data-action="details"]');
      if (!button) return;
      const article = button.closest('.entry');
      if (!article) return;
      openDetail(article.dataset.id);
    });

    document.getElementById('favorite-toggle').addEventListener('click', (event) => {
      const id = event.target.dataset.id;
      if (!id) return;
      toggleFavorite(id);
    });

    document.getElementById('detail-drawer').addEventListener('click', (event) => {
      if (event.target.id === 'detail-drawer') {
        closeDetail();
      }
    });

    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        closeDetail();
      }
    });

    async function init() {
      favorites = loadFavorites();
      wirePackControls();
      subscribeToPackChanges();
      await hydratePackData();
    }

    document.addEventListener('DOMContentLoaded', () => {
      list.style.height = '0px';
      init();
    });
  </script>
</body>
</html>
