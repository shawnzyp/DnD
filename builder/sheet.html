<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Character Sheet Â· Builder Export</title>
  <meta name="theme-color" content="#fdfdfd" />
  <link rel="manifest" href="../manifest.webmanifest" />
  <script src="../js/loader.js" defer></script>
  <script src="../js/app.js" type="module" defer></script>
  <style>
    :root {
      color-scheme: light;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      --bg: #fdfdfd;
      --fg: #111827;
      --muted: #6b7280;
      --accent: #2563eb;
      --border: rgba(17, 24, 39, 0.12);
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
    }
    @page {
      size: Letter;
      margin: 0.5in;
    }
    @media print {
      body {
        background: white;
      }
      .print-actions {
        display: none !important;
      }
    }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem;
    }
    main.sheet {
      width: min(100%, 8.5in - 1in);
      display: grid;
      gap: 1rem;
    }
    header.sheet-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      border-bottom: 2px solid var(--border);
      padding-bottom: 0.6rem;
    }
    header.sheet-header h1 {
      margin: 0;
      font-size: 1.6rem;
    }
    header.sheet-header p {
      margin: 0.2rem 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }
    .print-actions {
      display: flex;
      gap: 0.5rem;
    }
    .print-actions button {
      border: 1px solid var(--border);
      border-radius: 0.6rem;
      background: white;
      color: var(--fg);
      padding: 0.45rem 0.85rem;
      font-weight: 600;
      cursor: pointer;
    }
    .columns {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
    }
    section.card {
      border: 1px solid var(--border);
      border-radius: 0.75rem;
      padding: 0.85rem;
      display: grid;
      gap: 0.6rem;
      background: white;
    }
    section.card h2 {
      margin: 0;
      font-size: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .abilities-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.6rem;
    }
    .companion-stats {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin: 0.35rem 0;
    }
    .companion-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: rgba(37, 99, 235, 0.08);
    }
    .companion-chip strong {
      font-size: 0.85rem;
    }
    .companion-chip span {
      font-size: 0.7rem;
      color: var(--muted);
    }
    #companion-content p {
      margin: 0.25rem 0;
    }
    .companion-notes {
      background: rgba(37, 99, 235, 0.08);
      border-radius: 0.6rem;
      padding: 0.5rem 0.6rem;
      font-size: 0.85rem;
    }
    .companion-traits {
      margin: 0.35rem 0 0;
      padding-left: 1.1rem;
    }
    .companion-traits li {
      margin-bottom: 0.2rem;
    }
    .ability-card {
      border: 1px solid rgba(17,24,39,0.08);
      border-radius: 0.6rem;
      padding: 0.6rem;
      display: grid;
      gap: 0.35rem;
    }
    .ability-card header {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .ability-card strong {
      font-size: 1.25rem;
    }
    table.simple {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.85rem;
    }
    table.simple th, table.simple td {
      border: 1px solid rgba(17,24,39,0.08);
      padding: 0.4rem 0.5rem;
      text-align: left;
    }
    table.simple th {
      background: rgba(37, 99, 235, 0.08);
      color: var(--fg);
      font-weight: 600;
    }
    .note {
      color: var(--muted);
      font-size: 0.8rem;
    }
    ul.rest-log {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 0.35rem;
      font-size: 0.82rem;
    }
  </style>
</head>
<body>
  <main class="sheet">
    <header class="sheet-header">
      <div>
        <h1 id="sheet-name">Adventurer</h1>
        <p id="sheet-summary">Level 1 Hero</p>
      </div>
      <div class="print-actions">
        <button type="button" id="print-sheet">Print</button>
        <button type="button" id="close-sheet">Close</button>
      </div>
    </header>
    <section class="columns">
      <section class="card" id="abilities-card">
        <h2>Ability Scores</h2>
        <div class="abilities-grid" id="abilities-grid"></div>
      </section>
      <section class="card" id="resources-card">
        <h2>Resources</h2>
        <table class="simple" id="resources-table"></table>
        <p class="note">Values reflect the latest saved builder and play data.</p>
      </section>
      <section class="card" id="companion-card">
        <h2>Companion</h2>
        <div id="companion-content"></div>
      </section>
    </section>
    <section class="columns">
      <section class="card" id="counters-card">
        <h2>Class Trackers</h2>
        <table class="simple" id="counters-table"></table>
        <p class="note" id="counters-note"></p>
      </section>
      <section class="card" id="concentration-card">
        <h2>Concentration</h2>
        <p id="concentration-status"></p>
        <table class="simple" id="concentration-table"></table>
      </section>
    </section>
    <section class="card" id="rest-card">
      <h2>Rest History</h2>
      <ul class="rest-log" id="rest-log"></ul>
    </section>
  </main>
  <script type="module">
    const abilityFields = [
      { id: 'str', label: 'Strength', short: 'STR' },
      { id: 'dex', label: 'Dexterity', short: 'DEX' },
      { id: 'con', label: 'Constitution', short: 'CON' },
      { id: 'int', label: 'Intelligence', short: 'INT' },
      { id: 'wis', label: 'Wisdom', short: 'WIS' },
      { id: 'cha', label: 'Charisma', short: 'CHA' }
    ];

    function parseNumber(value, fallback = 0) {
      const parsed = typeof value === 'number' ? value : parseInt(value, 10);
      return Number.isFinite(parsed) ? parsed : fallback;
    }

    function formatModifier(score) {
      if (!Number.isFinite(score)) return '+0';
      const mod = Math.floor((score - 10) / 2);
      return mod >= 0 ? `+${mod}` : `${mod}`;
    }

    function getPackData() {
      return window.dndData || { classes: [] };
    }

    function resolveClassMeta(identifier) {
      const { classes = [] } = getPackData();
      return classes.find(entry => entry.slug === identifier || entry.id === identifier || entry.name === identifier) || null;
    }

    function formatCompanionSpeed(value) {
      if (value === null || value === undefined) return '';
      if (typeof value === 'string') return value;
      if (Array.isArray(value)) {
        return value
          .map((entry) => (entry && typeof entry === 'object' && 'label' in entry ? entry.label : entry))
          .filter(Boolean)
          .map((entry) => String(entry).trim())
          .filter(Boolean)
          .join(', ');
      }
      if (typeof value === 'object') {
        const parts = [];
        Object.entries(value).forEach(([mode, raw]) => {
          if (raw === null || raw === undefined) return;
          if (typeof raw === 'object') {
            const distance = raw.distance || raw.value || raw.speed || raw.amount;
            if (distance) {
              parts.push(`${mode.replace(/_/g, ' ')} ${distance}`);
            }
          } else {
            parts.push(`${mode.replace(/_/g, ' ')} ${raw}`);
          }
        });
        return parts.join(', ');
      }
      return String(value);
    }

    function collectCompanionFeatures(target, value) {
      if (value === null || value === undefined) return;
      if (Array.isArray(value)) {
        value.forEach((entry) => collectCompanionFeatures(target, entry));
        return;
      }
      if (typeof value === 'object') {
        if ('name' in value) collectCompanionFeatures(target, value.name);
        if ('feature' in value) collectCompanionFeatures(target, value.feature);
        if ('title' in value) collectCompanionFeatures(target, value.title);
        if ('label' in value) collectCompanionFeatures(target, value.label);
        if ('features' in value) collectCompanionFeatures(target, value.features);
        return;
      }
      const text = String(value);
      text.split(/[;,]/).forEach((part) => {
        const trimmed = part.trim();
        if (trimmed) {
          target.push(trimmed);
        }
      });
    }

    function extractCompanionFeatures(entry) {
      const features = [];
      const candidates = [
        entry.requiredFeatures,
        entry.requirements,
        entry.requirement,
        entry.prerequisites,
        entry.requires,
        entry.featureRequirements,
        entry.featuresRequired,
        entry.prerequisiteFeatures
      ];
      candidates.forEach((candidate) => collectCompanionFeatures(features, candidate));
      return Array.from(new Set(features));
    }

    function normalizeCompanion(entry) {
      if (!entry) return null;
      const id = entry.slug || entry.id || entry.name;
      if (!id) return null;
      const name = entry.name || id;
      const ac = Number.isFinite(entry.armor_class)
        ? entry.armor_class
        : Number.isFinite(entry.ac)
          ? entry.ac
          : Number.isFinite(entry.armorClass)
            ? entry.armorClass
            : null;
      const hp = Number.isFinite(entry.hit_points)
        ? entry.hit_points
        : Number.isFinite(entry.hp)
          ? entry.hp
          : Number.isFinite(entry.hitPoints)
            ? entry.hitPoints
            : null;
      const speed = formatCompanionSpeed(entry.speed || entry.speeds || entry.movement || entry.movementModes);
      const senses = Array.isArray(entry.senses) ? entry.senses.join(', ') : (entry.senses || '');
      const skills = Array.isArray(entry.skills) ? entry.skills.join(', ') : (entry.skills || '');
      const traits = Array.isArray(entry.traits)
        ? entry.traits.map((trait) => {
            if (!trait && trait !== 0) return null;
            if (typeof trait === 'string') return trait.trim();
            if (typeof trait === 'object') {
              const label = trait.name || trait.title || '';
              const text = trait.desc || trait.description || trait.text || '';
              return [label, text].filter(Boolean).join('. ').trim();
            }
            return String(trait).trim();
          }).filter(Boolean)
        : typeof entry.traits === 'string'
          ? [entry.traits.trim()]
          : [];
      return {
        id,
        name,
        summary: entry.summary || entry.description || '',
        ac,
        hp,
        speed,
        cr: entry.challenge_rating || entry.challengeRating || entry.cr || '',
        size: entry.size || '',
        type: entry.type || entry.creature_type || entry.category || '',
        alignment: entry.alignment || '',
        senses,
        skills,
        traits,
        features: extractCompanionFeatures(entry),
        source: (entry.source && entry.source.name) || entry.sourceId || ''
      };
    }

    function normalizeCompanionSnapshot(meta) {
      if (!meta || typeof meta !== 'object') return null;
      const id = meta.id || meta.slug || meta.name;
      if (!id) return null;
      const parseStat = (value) => {
        if (Number.isFinite(value)) return value;
        const parsed = Number.parseInt(value, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      const rawCr = meta.cr ?? meta.crLabel ?? meta.challenge_rating ?? meta.challengeRating;
      const cr = rawCr || rawCr === 0 ? String(rawCr) : '';
      const size = meta.size ? String(meta.size) : '';
      const type = (meta.type || meta.creature_type || meta.category)
        ? String(meta.type || meta.creature_type || meta.category)
        : '';
      const alignment = meta.alignment ? String(meta.alignment) : '';
      const senses = Array.isArray(meta.senses)
        ? meta.senses.map((entry) => (entry && entry.label ? entry.label : entry)).filter(Boolean).map((entry) => String(entry).trim()).filter(Boolean).join(', ')
        : meta.senses
          ? String(meta.senses)
          : '';
      const skills = Array.isArray(meta.skills)
        ? meta.skills.map((entry) => (entry && entry.label ? entry.label : entry)).filter(Boolean).map((entry) => String(entry).trim()).filter(Boolean).join(', ')
        : meta.skills
          ? String(meta.skills)
          : '';
      const traits = Array.isArray(meta.traits)
        ? meta.traits
            .map((trait) => {
              if (!trait && trait !== 0) return null;
              if (typeof trait === 'string') return trait.trim();
              if (typeof trait === 'object') {
                const label = trait.name || trait.title || '';
                const text = trait.desc || trait.description || trait.text || '';
                return [label, text].filter(Boolean).join('. ').trim();
              }
              return String(trait).trim();
            })
            .filter(Boolean)
        : typeof meta.traits === 'string'
          ? [meta.traits.trim()].filter(Boolean)
          : [];
      const features = Array.isArray(meta.features)
        ? meta.features.map((feature) => String(feature).trim()).filter(Boolean)
        : [];
      const source = meta.source && typeof meta.source === 'object'
        ? meta.source.name || meta.source.title || meta.source.id || ''
        : meta.source || '';
      const speed = formatCompanionSpeed(
        meta.speed ?? meta.speeds ?? meta.movement ?? meta.movementModes ?? meta.speedText ?? meta.speedLabel
      );
      return {
        id: String(id),
        name: meta.name ? String(meta.name) : String(id),
        summary: meta.summary ? String(meta.summary) : '',
        ac: parseStat(meta.ac ?? meta.armor_class ?? meta.armorClass),
        hp: parseStat(meta.hp ?? meta.hit_points ?? meta.hitPoints),
        speed,
        cr,
        size,
        type,
        alignment,
        senses,
        skills,
        traits,
        features,
        source: source ? String(source) : ''
      };
    }

    function findCompanion(identifier) {
      if (!identifier && identifier !== 0) return null;
      const key = String(identifier).trim().toLowerCase();
      if (!key) return null;
      const { companions = [] } = getPackData();
      for (let index = 0; index < companions.length; index += 1) {
        const entry = companions[index];
        if (!entry) continue;
        const slug = entry.slug ? String(entry.slug).toLowerCase() : null;
        const id = entry.id ? String(entry.id).toLowerCase() : null;
        const name = entry.name ? String(entry.name).toLowerCase() : null;
        if (slug === key || id === key || name === key) {
          return normalizeCompanion(entry);
        }
      }
      return null;
    }

    function loadState(key) {
      try {
        const raw = localStorage.getItem(key);
        return raw ? JSON.parse(raw) : null;
      } catch (error) {
        console.warn('Failed to load state', key, error);
        return null;
      }
    }

    function renderSheet() {
      const builderState = window.dndBuilderState || loadState('dndBuilderState') || { data: {} };
      const playState = loadState('dndPlayState') || {
        hp: { current: 10, max: 10, temp: 0 },
        hitDice: { total: 1, available: 1, die: 'd8' },
        classCounters: [],
        wildShape: { max: 0, remaining: 0 },
        concentration: { active: false, spell: '', notes: '' },
        restLog: []
      };

      const classMeta = resolveClassMeta(builderState.data?.class);
      const proficientSaves = new Set((classMeta && classMeta.saving_throws) || []);
      const level = parseNumber(builderState.data?.level, 1);
      const proficiency = Math.max(2, Math.floor((level - 1) / 4) + 2);

      document.getElementById('sheet-name').textContent = builderState.data?.name || 'Unnamed Adventurer';
      const subtitleParts = [
        builderState.data?.class ? `Level ${builderState.data?.level || 1} ${builderState.data.class}` : null,
        builderState.data?.subclass || null,
        builderState.data?.background ? `Background: ${builderState.data.background}` : null,
        builderState.data?.alignment ? `Alignment: ${builderState.data.alignment}` : null
      ].filter(Boolean);
      document.getElementById('sheet-summary').textContent = subtitleParts.join(' Â· ') || 'Complete the builder to enrich this sheet.';

      const abilitiesGrid = document.getElementById('abilities-grid');
      abilitiesGrid.innerHTML = '';
      const abilityNameMap = {
        str: 'Strength', dex: 'Dexterity', con: 'Constitution', int: 'Intelligence', wis: 'Wisdom', cha: 'Charisma'
      };
      abilityFields.forEach(field => {
        const score = parseNumber(builderState.data?.[field.id], 10) || 10;
        const mod = formatModifier(score);
        const saveProf = proficientSaves.has(abilityNameMap[field.id]);
        const saveBonus = saveProf ? formatModifier(score + proficiency) : mod;
        const card = document.createElement('div');
        card.className = 'ability-card';
        card.innerHTML = `
          <header><span>${field.short}</span><span>${abilityNameMap[field.id]}</span></header>
          <strong>${score}</strong>
          <span>Modifier: ${mod}</span>
          <span>Save: ${saveProf ? saveBonus + ' (prof)' : saveBonus}</span>
        `;
        abilitiesGrid.appendChild(card);
      });

      const resourcesTable = document.getElementById('resources-table');
      resourcesTable.innerHTML = `
        <tr><th>Resource</th><th>Value</th><th>Notes</th></tr>
        <tr><td>Hit Points</td><td>${playState.hp.current} / ${playState.hp.max}</td><td>Temp HP: ${playState.hp.temp || 0}</td></tr>
        <tr><td>Hit Dice</td><td>${playState.hitDice.available} / ${playState.hitDice.total}</td><td>Die: ${playState.hitDice.die || 'd8'}</td></tr>
        ${playState.wildShape && playState.wildShape.max ? `<tr><td>Wild Shape</td><td>${playState.wildShape.remaining} / ${playState.wildShape.max}</td><td>Resets on short rest</td></tr>` : ''}
      `;

      const companionContent = document.getElementById('companion-content');
      if (companionContent) {
        companionContent.innerHTML = '';
        const familiar = builderState.data?.familiar || {};
        const snapshot = normalizeCompanionSnapshot(familiar.meta);
        const fallbackId = familiar.id || builderState.data?.familiarType || '';
        const resolvedId = fallbackId || (snapshot ? snapshot.id : '');
        const customName = familiar.name || builderState.data?.familiarName || '';
        const notes = familiar.notes || builderState.data?.familiarNotes || '';
        const overrides = familiar.overrides || {};
        if (!resolvedId && !notes) {
          const empty = document.createElement('p');
          empty.className = 'note';
          empty.textContent = 'No companion tracked.';
          companionContent.appendChild(empty);
        } else {
          let entry = findCompanion(resolvedId);
          if (!entry && snapshot) {
            entry = snapshot;
          }
          if (!entry) {
            const message = resolvedId ? `Companion data not found for ${resolvedId}.` : 'Companion data not available.';
            const info = document.createElement('p');
            info.className = 'note';
            info.textContent = message;
            companionContent.appendChild(info);
            if (notes) {
              const noteEl = document.createElement('p');
              noteEl.className = 'companion-notes';
              noteEl.textContent = notes;
              companionContent.appendChild(noteEl);
            }
          } else {
            const acOverride = Number.isFinite(overrides.ac) ? overrides.ac : null;
            const hpOverride = Number.isFinite(overrides.hp) ? overrides.hp : null;
            const speedOverride = overrides.speed ? overrides.speed : '';
            const title = document.createElement('h3');
            title.textContent = customName || entry.name;
            companionContent.appendChild(title);
            const subtitleParts = [];
            if (entry.cr) subtitleParts.push(`CR ${entry.cr}`);
            if (entry.size) subtitleParts.push(entry.size);
            if (entry.type) subtitleParts.push(entry.type);
            if (entry.alignment) subtitleParts.push(entry.alignment);
            if (subtitleParts.length) {
              const subtitle = document.createElement('p');
              subtitle.className = 'note';
              subtitle.textContent = subtitleParts.join(' Â· ');
              companionContent.appendChild(subtitle);
            }
            if (customName && customName.toLowerCase() !== entry.name.toLowerCase()) {
              const baseName = document.createElement('p');
              baseName.className = 'note';
              baseName.textContent = `Base creature: ${entry.name}`;
              companionContent.appendChild(baseName);
            }
            if (entry.summary) {
              const summary = document.createElement('p');
              summary.className = 'note';
              summary.textContent = entry.summary;
              companionContent.appendChild(summary);
            }
            const stats = document.createElement('div');
            stats.className = 'companion-stats';
            let hasStats = false;
            const addChip = (label, value, note) => {
              const chip = document.createElement('span');
              chip.className = 'companion-chip';
              chip.append(document.createTextNode(`${label} `));
              const strong = document.createElement('strong');
              strong.textContent = String(value);
              chip.appendChild(strong);
              if (note) {
                const noteEl = document.createElement('span');
                noteEl.textContent = note;
                chip.appendChild(noteEl);
              }
              stats.appendChild(chip);
              hasStats = true;
            };
            const acValue = acOverride ?? entry.ac;
            if (acValue !== null && acValue !== undefined && acValue !== '') {
              const note = acOverride && entry.ac !== null && entry.ac !== undefined && entry.ac !== '' ? `override Â· base ${entry.ac}` : (acOverride ? 'override' : '');
              addChip('AC', acValue, note);
            }
            const hpValue = hpOverride ?? entry.hp;
            if (hpValue !== null && hpValue !== undefined && hpValue !== '') {
              const note = hpOverride && entry.hp !== null && entry.hp !== undefined && entry.hp !== '' ? `override Â· base ${entry.hp}` : (hpOverride ? 'override' : '');
              addChip('HP', hpValue, note);
            }
            const speedValue = speedOverride || entry.speed;
            if (speedValue) {
              const note = speedOverride && entry.speed ? `override Â· base ${entry.speed}` : (speedOverride ? 'override' : '');
              addChip('Speed', speedValue, note);
            }
            if (hasStats) {
              companionContent.appendChild(stats);
            }
            const appendMeta = (label, value) => {
              if (!value) return;
              const meta = document.createElement('p');
              meta.className = 'note';
              meta.textContent = `${label}: ${value}`;
              companionContent.appendChild(meta);
            };
            if (entry.features.length) {
              appendMeta('Requires', entry.features.join(', '));
            }
            appendMeta('Senses', entry.senses);
            appendMeta('Skills', entry.skills);
            if (entry.traits.length) {
              const traitList = document.createElement('ul');
              traitList.className = 'companion-traits';
              entry.traits.forEach((trait) => {
                const item = document.createElement('li');
                item.textContent = trait;
                traitList.appendChild(item);
              });
              companionContent.appendChild(traitList);
            }
            appendMeta('Source', entry.source);
            if (notes) {
              const noteEl = document.createElement('p');
              noteEl.className = 'companion-notes';
              noteEl.textContent = notes;
              companionContent.appendChild(noteEl);
            }
          }
        }
      }

      const countersTable = document.getElementById('counters-table');
      countersTable.innerHTML = '';
      if (playState.classCounters && playState.classCounters.length) {
        countersTable.innerHTML = '<tr><th>Feature</th><th>Remaining</th><th>Reset</th></tr>' +
          playState.classCounters.map(counter => `<tr><td>${counter.name}</td><td>${counter.current} / ${counter.max}</td><td>${counter.reset || 'short'}</td></tr>`).join('');
        document.getElementById('counters-note').textContent = '';
      } else {
        document.getElementById('counters-note').textContent = 'Add trackers in the builder summary to surface them here.';
      }

      const concentrationStatus = document.getElementById('concentration-status');
      const concentrationTable = document.getElementById('concentration-table');
      if (playState.concentration?.active) {
        concentrationStatus.textContent = `Concentrating on ${playState.concentration.spell || 'a spell'}`;
        concentrationTable.innerHTML = `<tr><th>Notes</th></tr><tr><td>${playState.concentration.notes || 'Maintain Constitution saves after damage.'}</td></tr>`;
      } else {
        concentrationStatus.textContent = 'No active concentration spell.';
        concentrationTable.innerHTML = '';
      }

      const restLog = document.getElementById('rest-log');
      restLog.innerHTML = '';
      if (playState.restLog && playState.restLog.length) {
        const formatter = new Intl.DateTimeFormat(undefined, { dateStyle: 'short', timeStyle: 'short' });
        playState.restLog.forEach(entry => {
          const item = document.createElement('li');
          item.textContent = `${entry.type === 'long' ? 'Long Rest' : 'Short Rest'} Â· ${formatter.format(new Date(entry.at))}`;
          restLog.appendChild(item);
        });
      } else {
        const item = document.createElement('li');
        item.textContent = 'No rests recorded yet.';
        restLog.appendChild(item);
      }
    }

    document.getElementById('print-sheet').addEventListener('click', () => {
      window.print();
    });

    document.getElementById('close-sheet').addEventListener('click', () => {
      window.close();
    });

    window.addEventListener('dnd-data-ready', () => {
      renderSheet();
    });

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      renderSheet();
    } else {
      window.addEventListener('DOMContentLoaded', renderSheet);
    }
  </script>
</body>
</html>
